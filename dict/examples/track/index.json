{
  "Changes are first-class values in ProseMirror. You can hold on to them, and do things with them. Such as rebasing them across other changes, inverting them, or inspecting them to see what they did.": {
    "_translate": "变化在ProseMirror中是一级值。你可以保留它们，并对它们进行操作。例如<a href=\"/docs/guide/#transform.rebasing\">重新基准化</a>它们，反转它们，或检查它们以查看它们的作用。",
    "_note": ""
  },
  "This example uses those properties to allow you to “commit” your changes, to revert individual commits, and to find out which commit a piece of text originates from.": {
    "_translate": "此示例使用这些属性允许您“提交”您的更改，恢复单个提交，并找出某段文本的提交来源。",
    "_note": ""
  },
  "Hover over commits to highlight the text they introduced.": {
    "_translate": "将鼠标悬停在提交上以突出显示它们引入的文本。",
    "_note": ""
  },
  "This page won't list the whole source code for the example, only the most interesting parts.": {
    "_translate": "此页面不会列出<a href=\"https://github.com/ProseMirror/website/blob/master/example/track/index.js\">完整的源代码</a>，仅列出最有趣的部分。",
    "_note": ""
  },
  "The first thing we need is a way to track the commit history. An editor plugin works well for this, since it can observe changes as they come in. This is what the plugin's state value looks like:": {
    "_translate": "我们首先需要的是一种跟踪提交历史的方法。一个编辑器插件对此非常有效，因为它可以观察到变化的到来。这是插件的状态值的样子：",
    "_note": ""
  },
  "The plugin itself does little more than watch transactions and update its state. When a meta property tagged by the plugin is present on the transaction, it is a commit transaction, and the property's value is the commit message.": {
    "_translate": "插件本身除了监视事务和更新其状态外，几乎没有其他作用。当事务中存在由插件标记的元属性时，它是一个提交事务，并且该属性的值是提交消息。",
    "_note": ""
  },
  "Tracking history like this allows for all kinds of useful things, such as figuring out who added a given piece of code, and when. Or reverting individual commits.": {
    "_translate": "跟踪这样的历史可以实现各种有用的功能，例如找出是谁在何时添加了某段代码，或者还原单个提交。",
    "_note": ""
  },
  "Reverting an old steps requires rebasing the inverted form of those steps over all intermediate steps. That is what this function does.": {
    "_translate": "恢复旧步骤需要将这些步骤的反向形式<a href=\"/docs/guide/#transform.rebasing\">变基</a>到所有中间步骤之上。这就是这个函数的作用。",
    "_note": ""
  },
  "Due to the implicit conflict resolution when moving changes across each other, outcomes of complicated reverts, where later changes touch the same content, can sometimes be unintuitive. In a production application, it may be desirable to detect such conflicts and provide the user with an interface to resolve them.": {
    "_translate": "由于在移动更改时隐式解决冲突，当后续更改触及相同内容时，复杂的还原结果有时可能不直观。在生产应用中，可能需要检测此类冲突并为用户提供解决这些冲突的界面。",
    "_note": ""
  }
}