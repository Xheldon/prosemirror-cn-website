{
  "ProseMirror is structured as a number of separate modules. This reference manual describes the exported API per module. If you want to use something from the prosemirror-state module, for example, you can import it like this:": {
    "_translate": "ProseMirror 由多个单独的模块构成。这个手册描述了每个模块导出的 API。例如，如果你想使用 <a href=\"#state\"><code>prosemirror-state</code></a> 模块，你可以像下面这样导入即可：",
    "_note": ""
  },
  "This is the reference manual for the ProseMirror rich text editor. It lists and describes the full public API exported by the library. For more introductory material, please see the guide.": {
    "_translate": "本页面是富文本编辑器 <a href=\"https://prosemirror.xheldon.com\">ProseMirror</a> 的 API 手册，它列出和描述了该库导出的全部接口。想了解更多关于它的介绍，请访问：<a href=\"/docs/guide/\">指南</a>",
    "_note": ""
  },
  "Or, using ES6 syntax:": {
    "_translate": "或者使用 ES6 的语法：",
    "_note": ""
  },
  "This module implements the state object of a ProseMirror editor, along with the representation of the selection and the plugin abstraction.": {
    "_translate": "本模块实现了 ProseMirror 编辑器的 state 对象，以及关于选区 selection 和 插件 plugin 的抽象。",
    "_note": ""
  },
  "ProseMirror keeps all editor state (the things, basically, that would be required to create an editor just like the current one) in a single object. That object is updated (creating a new state) by applying transactions to it.": {
    "_translate": "ProseMirror 使用一个单独的大 <a href=\"#state.EditorState\">对象</a> 来保持对编辑器所有 state 的引用（基本上来说，需要创建一个与当前编辑器相同的编辑器）。 这个对象通过应用一个 <a href=\"#state.Transaction\">transactions</a> 来更新（即创建一个新的 state）。",
    "_note": "transactions 按惯例在写代码的或者看源码的时候被缩写成 tr"
  },
  "The state of a ProseMirror editor is represented by an object of this type. A state is a persistent data structure—it isn't updated, but rather a new state value is computed from an old one using the apply method.": {
    "_translate": "ProseMirror 编辑器状态由此对象表示。一个 state 是一个持久化的数据结构--它本身并不更新，旧的 state 通过 <a href=\"#state.EditorState.apply\"><code>apply</code></a> 方法产生一个新的 state。",
    "_note": ""
  },
  "A state holds a number of built-in fields, and plugins can define additional fields.": {
    "_translate": "一个 state 有很多内建的字段，同时可以通过 plugins 来 <a href=\"#state.PluginSpec.state\">定义</a> 额外的字段。",
    "_note": ""
  },
  "The current document.": {
    "_translate": "当前文档",
    "_note": ""
  },
  "The selection.": {
    "_translate": "当前选区。",
    "_note": ""
  },
  "The schema of the state's document.": {
    "_translate": "state 所表示的文档的 schema。",
    "_note": ""
  },
  "A set of marks to apply to the next input. Will be null when no explicit marks have been set.": {
    "_translate": "即将要应用到下一次输入的 marks。如果没有显式的设置 marks，此字段将会是 null。",
    "_note": ""
  },
  "The plugins that are active in this state.": {
    "_translate": "在当前 state 中激活的 plugins。",
    "_note": ""
  },
  "Apply the given transaction to produce a new state.": {
    "_translate": "对旧的 state 应用给定的 transaction 以产生一个新的 state。",
    "_note": ""
  },
  "Verbose variant of apply that returns the precise transactions that were applied (which might be influenced by the transaction hooks of plugins) along with the new state.": {
    "_translate": "<a href=\"#state.EditorState.apply\"><code>apply</code></a> 的复杂版。该接口返回将应用到旧 state 以产生新 state 的每一个 transactions （其返回解构可能被插件的 <a href=\"#state.PluginSpec.filterTransaction\">transaction hooks</a> 影响。）",
    "_note": ""
  },
  "Start a transaction from this state.": {
    "_translate": "从当前 state 生成一个新的 <a href=\"#state.Transaction\">transaction</a> 以对当前 state 进行修改。",
    "_note": "该 transaction 是一个 getter 函数，每次调用都会 new 一个新的 transaction。"
  },
  "Create a new state based on this one, but with an adjusted set of active plugins. State fields that exist in both sets of plugins are kept unchanged. Those that no longer exist are dropped, and those that are new are initialized using their init method, passing in the new configuration object..": {
    "_translate": "基于当前的 state 新建一个新的 state，只是新的 state 的中的字段会由传入的 plugins 重新配置。新旧两组 plugins 中的 state 字段中都存在的字段保持不变。 （相比于旧的 plugins 中）不再存在的字段将会被丢弃，新增的字段将会使用 plugin 的 state 对象的 <a href=\"#state.StateField.init\"><code>init</code></a> 方法进行初始化后作为新的 state 字段。",
    "_note": "plugin 配置对象有一个 state 字段，其有两个方法，一个是 init 用来初始化 state；一个是 apply，用来决定如何更新 state。此 create 方法对于新增的 plugin 会调用其 state 的 init 方法进行初始化，以生成编辑器的 state。"
  },
  "New set of active plugins.": {
    "_translate": "新的激活的插件集合。",
    "_note": "plugins 上的 state 构成新的编辑器的 state。"
  },
  "Create a new state.": {
    "_translate": "创建一个新的 state。",
    "_note": ""
  },
  "Serialize this state to JSON. If you want to serialize the state of plugins, pass an object mapping property names to use in the resulting JSON object to plugin objects. The argument may also be a string or number, in which case it is ignored, to support the way JSON.stringify calls toString methods.": {
    "_translate": "将 state 对象序列化成 JSON 对象。如果你想序列化 plugin 的 state，则需要传递一个有着属性名-插件的映射关系的对象，该对象的属性名就会出现在返回值结果对象中。 参数也可以是字符串或者数字，但这种情况下参数会被忽略，以支持以 <code>JSON.stringify</code> 的方式调用 <code>toString</code> 方法。",
    "_note": "如果想序列化 plugin 的 state，需要 plugin 的 state 对象有提供 toJSON 方法，该方法的参数是 plugin 的 key。doc 和 selection 是保留字段，不能作为参数对象的属性名。"
  },
  "Deserialize a JSON representation of a state. config should have at least a schema field, and should contain array of plugins to initialize the state with. pluginFields can be used to deserialize the state of plugins, by associating plugin instances with the property names they use in the JSON object.": {
    "_translate": "反序列化一个 state 的 JSON 表示。<code>config</code> 至少应该有一个 <code>schema</code> 字段，并且应该包含用来初始化 state 的 plugin 数组。 <code>pluginField</code> 参数通过在 JSON 对象中的属性名与 plugin 实例对应的方式来反序列化 plugin 的 state。",
    "_note": "pluginFields 中的属性名如果对应到了某个 plugin 的 key（string），则会调用对应 plugin 的 state 的 fromJSON 方法， 如果没有对应到任一个 plugin 的 key，则会直接调 plugin 的 state 的 init 方法，前者参数是 config、插件对应的 json 和根据 config 生成的编辑器 state；后者参数是 config 和根据 config 生成的编辑器的 state。"
  },
  "The schema to use.": {
    "_translate": "反序列化用到的 schema。",
    "_note": ""
  },
  "The set of active plugins.": {
    "_translate": "激活插件的集合。",
    "_note": ""
  },
  "The type of object passed to EditorState.create.": {
    "_translate": "传递给<a href=\"#state.EditorState%5Ecreate\"><code>EditorState.create</code></a>的对象类型。",
    "_note": ""
  },
  "The schema to use (only relevant if no doc is specified).": {
    "_translate": "当前编辑器所使用的 schema。",
    "_note": ""
  },
  "The starting document. Either this or schema must be provided.": {
    "_translate": "起始文档。必须提供此文档或<code>schema</code><em>。</em>",
    "_note": ""
  },
  "A valid selection in the document.": {
    "_translate": "文档中可用的选区。",
    "_note": ""
  },
  "The initial set of stored marks.": {
    "_translate": "<a href=\"#state.EditorState.storedMarks\">stored marks</a> 的初始集合。",
    "_note": ""
  },
  "The plugins that should be active in this state.": {
    "_translate": "state 中激活的 plugins。",
    "_note": ""
  },
  "An editor state transaction, which can be applied to a state to create an updated state. Use EditorState.tr to create an instance.": {
    "_translate": "一个编辑器 state 的 transaction 可以被用来应用到 state 以创建一个更新的 state。 使用 <a href=\"#state.EditorState.tr\"><code>EditorState.tr</code></a> 来创建一个 transaction 实例。",
    "_note": "EditorState.tr 是一个 getter 函数，每次调用都会 new 一个新的。"
  },
  "Transactions track changes to the document (they are a subclass of Transform), but also other state changes, like selection updates and adjustments of the set of stored marks. In addition, you can store metadata properties in a transaction, which are extra pieces of information that client code or plugins can use to describe what a transaction represents, so that they can update their own state accordingly.": {
    "_translate": "transaction 跟踪文档的更改（它们是<a href=\"#transform.Transform\"><code>Transform</code></a>的子类），但也包括其他状态更改，如选择更新和<a href=\"#state.EditorState.storedMarks\">storedMarks</a>集合的调整。此外，您可以在 transaction 中存储 metadata属性，这些属性是客户端代码或插件可以使用的额外信息，用于描述 transaction 代表的内容，以便它们可以相应地更新其<a href=\"#state.StateField\">自己的状态</a>。",
    "_note": ""
  },
  "The timestamp associated with this transaction, in the same format as Date.now().": {
    "_translate": "与当前 transaction 关联的时间戳，与 <code>Date.now()</code> 格式相同。",
    "_note": ""
  },
  "The editor view uses a few metadata properties: it will attach a property \"pointer\" with the value true to selection transactions directly caused by mouse or touch input, a \"composition\" property holding an ID identifying the composition that caused it to transactions caused by composed DOM input, and a \"uiEvent\" property of that may be \"paste\", \"cut\", or \"drop\".": {
    "_translate": "<a href=\"#view.EditorView\">编辑器视图</a> 使用了一些元数据属性：它会将一个属性 <code>\"pointer\"</code> 值为 <code>true</code> 附加到由鼠标或触摸输入直接引起的选择 transaction 上，一个 <code>\"composition\"</code> 属性持有一个 ID 标识符，标识由组合 DOM 输入引起的 transaction 的组合，以及一个 <code>\"uiEvent\"</code> 属性，可能是 <code>\"paste\"</code>、<code>\"cut\"</code> 或 <code>\"drop\"</code>。",
    "_note": ""
  },
  "The stored marks set by this transaction, if any.": {
    "_translate": "当前 transaction 设置的 stored marks，如果有的话。",
    "_note": ""
  },
  "The transaction's current selection. This defaults to the editor selection mapped through the steps in the transaction, but can be overwritten with setSelection.": {
    "_translate": "该 transaction 的选区。默认是编辑器当前选区经过该 transaction <a href=\"#state.Selection.map\">mapped</a> 后的选区，不过也会被 <a href=\"#state.Transaction.setSelection\"><code>setSelection</code></a> 方法给手动设置。",
    "_note": ""
  },
  "Update the transaction's current selection. Will determine the selection that the editor gets when the transaction is applied.": {
    "_translate": "更新当前 transaction 的选区。其会决定 transaction 应用后编辑器的选区。",
    "_note": ""
  },
  "Whether the selection was explicitly updated by this transaction.": {
    "_translate": "选区是否被该 transaction 显式更新过。",
    "_note": "即在当前 transaction 中是否显式调用过 setSelection，一个 tr 在应用到 state 之前会 流过 所有的 plugin 的 apply 方法，因此这对于判断其他插件是否显式设置过选区很有用。"
  },
  "Set the current stored marks.": {
    "_translate": "设置 stored marks。",
    "_note": ""
  },
  "Make sure the current stored marks or, if that is null, the marks at the selection, match the given set of marks. Does nothing if this is already the case.": {
    "_translate": "确保 transaction 设置的 stored marks 或者如果 transaction 没有设置 stored marks 的话，确保光标位置的 marks，与参数给定的 marks 一致。 如果一致的话什么也不做。",
    "_note": "如果不一致的话，就让它们一致--这也是「确保」的含义。"
  },
  "Add a mark to the set of stored marks.": {
    "_translate": "在已经设置的 stored marks 集合中增加一个 mark。",
    "_note": ""
  },
  "Remove a mark or mark type from the set of stored marks.": {
    "_translate": "在已经设置的 stored marks 集合中移除一个 mark 或者移除一种 mark。",
    "_note": ""
  },
  "Whether the stored marks were explicitly set for this transaction.": {
    "_translate": "当前 transaction 是否显式设置了 stored marks。",
    "_note": ""
  },
  "Update the timestamp for the transaction.": {
    "_translate": "更新该 transaction 的时间戳。",
    "_note": ""
  },
  "Replace the current selection with the given slice.": {
    "_translate": "用给定的 slice 替换当前选区。",
    "_note": ""
  },
  "Delete the selection.": {
    "_translate": "删除选区。",
    "_note": "选区被删除了，其内容也一起被删除。"
  },
  "Replace the selection with the given node. When inheritMarks is true and the content is inline, it inherits the marks from the place where it is inserted.": {
    "_translate": "用给定的 node 替换当前选区。如果 <code>inheritMarks</code> 是 true 并且 node 的内容是 inline 的话，插入的内容将会继承插入点位置的 marks。",
    "_note": ""
  },
  "Replace the given range, or the selection if no range is given, with a text node containing the given string.": {
    "_translate": "用包含给定文本的文本节点替换给定的 range，如果没有给定 range 的话则替换选区。",
    "_note": "range 就是用 from 和 to 表示的一个范围。"
  },
  "Store a metadata property in this transaction, keyed either by name or by plugin.": {
    "_translate": "在该 transaction 上储存一个 metadata 信息，可以以 name 或者 plugin 来区分。",
    "_note": "因为一个 transaction 可能会被不同的 plugin 设置不同的 metadata 信息，因此需要区分。key 可以传 PluginKey，或者简单一个字符串。"
  },
  "Retrieve a metadata property for a given name or plugin.": {
    "_translate": "用给定的 name 或者 plugin key 来获取设置的 metadata 信息。",
    "_note": "给定的 name 或者 plugin key 就是上面 setMeta 设置的 key，获取的就是 setMeta 设置的 value。"
  },
  "Indicate that the editor should scroll the selection into view when updated to the state produced by this transaction.": {
    "_translate": "当该 transaction 更新完 state 后，让编辑器将选区滚动到视图窗口之内。",
    "_note": "类似 chrome devtools 中，Elements 下对某个元素右键的 「Scroll into view」"
  },
  "Returns true if this transaction doesn't contain any metadata, and can thus safely be extended.": {
    "_translate": "如果该 transaction 没有包含任何 metadata 信息则返回 true，如此以来就可以被安全的扩展。",
    "_note": "有些场景需要对 transaction 做一些额外处理，如合并多个 step，此时如果某个 step 有 metadata 信息，则说明该 step 对某个 plugin 可能有其他的用途，就不能简单的合并 step。"
  },
  "Commands are functions that take a state and a an optional transaction dispatch function and...": {
    "_translate": "命令是一些函数，它们接受一个状态和一个可选的 transaction 分发函数，并且...",
    "_note": ""
  },
  "True when this transaction has had scrollIntoView called on it.": {
    "_translate": "True when this transaction has had                 <code>scrollIntoView</code> called on it.",
    "_note": ""
  },
  "In some cases, the editor view is passed as a third argument.": {
    "_translate": "在某些情况下，编辑器视图作为第三个参数传递。",
    "_note": ""
  },
  "A ProseMirror selection can be one of several types. This module defines types for classical text selections (of which cursors are a special case) and node selections, where a specific document node is selected. It is possible to extend the editor with custom selection types.": {
    "_translate": "一个 ProseMirror selection 可以是多种不同类型的选区。这个模块定义了一个基础文本选区 <a href=\"#state.TextSelection\">text selections</a>（当然，光标是其中的一个特殊状态，即 selection 的内容为空） 和节点选区 <a href=\"#state.NodeSelection\"><em>node</em> selections</a> ，表示一个文档节点被选中。可以通过扩展 selection 父类来实现自定义的 selection 类型。",
    "_note": ""
  },
  "Superclass for editor selections. Every selection type should extend this. Should not be instantiated directly.": {
    "_translate": "编辑器选区的超类。所有的选区类型都扩展自它。不应该直接实例化。",
    "_note": ""
  },
  "Initialize a selection with the head and anchor and ranges. If no ranges are given, constructs a single range across $anchor and $head.": {
    "_translate": "用给定的 head 和 anchor 和 ranges 初始化一个选区。如果没有 ranges 给定，则构造一个包含 <code>$anchor</code> 和 <code>$head</code> 位置的 range。",
    "_note": ""
  },
  "The resolved anchor of the selection (the side that stays in place when the selection is modified).": {
    "_translate": "选区 resolved 过的 anchor 位置（即当选区变化的时候，其不动的一侧）。",
    "_note": ""
  },
  "The resolved head of the selection (the side that moves when the selection is modified).": {
    "_translate": "选区 resolved 过的 head 位置（即当选区变化时，移动的一侧）。",
    "_note": "「选区变化时」可能是用户造成的，如用户用鼠标从左到右选择，则选区起始（左侧）是 anchor，即「锚点」；选区右侧（鼠标所在位置）是 head，即动点。"
  },
  "The ranges covered by the selection.": {
    "_translate": "选区覆盖到的 ranges。",
    "_note": ""
  },
  "The selection's anchor, as an unresolved position.": {
    "_translate": "选区的 anchor 的位置。",
    "_note": ""
  },
  "The selection's head.": {
    "_translate": "选区的 head 的位置。",
    "_note": ""
  },
  "The lower bound of the selection's main range.": {
    "_translate": "选区位置较小一侧的位置。",
    "_note": "无论选区是如何选的，一般情况下 from 是选区的左侧起始位置。"
  },
  "The upper bound of the selection's main range.": {
    "_translate": "选区位置较大的一侧。",
    "_note": "无论选区是如何选的，一般情况下 to 是选区的右侧结束位置。"
  },
  "The resolved lower bound of the selection's main range.": {
    "_translate": "resolve 过的选区的位置较小的一侧。",
    "_note": ""
  },
  "The resolved upper bound of the selection's main range.": {
    "_translate": "resolve 过的选区的位置较大的一侧。",
    "_note": ""
  },
  "Indicates whether the selection contains any content.": {
    "_translate": "表示选区是否包含任何内容。",
    "_note": ""
  },
  "Test whether the selection is the same as another selection.": {
    "_translate": "测试当前选区与另一个选区是否相等。",
    "_note": ""
  },
  "Map this selection through a mappable thing. doc should be the new document to which we are mapping.": {
    "_translate": "通过一个 <a href=\"#transform.Mappable\">mappable</a> 对象来 map 当前选区。 <code>doc</code> 参数应该是我们正在 mapping 的新的 document。",
    "_note": "一般通过 tr.doc 拿到将要 mapping 到的新的 document。"
  },
  "Get the content of this selection as a slice.": {
    "_translate": "获取选区内容的 slice 形式。",
    "_note": ""
  },
  "Replace the selection with a slice or, if no slice is given, delete the selection. Will append to the given transaction.": {
    "_translate": "用给定的 slice 替换当前选区，如果没有给 slice，则删除选区。该操作会附加到给定 transaction 最后。",
    "_note": "替换后会将新的选区（光标）放到插入的内容的右侧。如果插入的内容是一个 inline 节点，则向右寻找该节点后面的位置。 如果不是 inline 节点，则向左寻找。"
  },
  "Replace the selection with the given node, appending the changes to the given transaction.": {
    "_translate": "用给定的 node 替换当前选区，该操作会附加到给定的 transaction 最后。",
    "_note": ""
  },
  "Convert the selection to a JSON representation. When implementing this for a custom selection class, make sure to give the object a type property whose value matches the ID under which you registered your class.": {
    "_translate": "将当前选区转换成 JSON 表示的格式。当在自己实现的 selection 类中实现此方法的时候，需要确保给这个返回的对象一个 <code>type</code> 属性， 属性值是你 <a href=\"#state.Selection%5EjsonID\">注册</a> selection 时候的 ID。",
    "_note": ""
  },
  "Get a bookmark for this selection, which is a value that can be mapped without having access to a current document, and later resolved to a real selection for a given document again. (This is used mostly by the history to track and restore old selections.) The default implementation of this method just converts the selection to a text selection and returns the bookmark for that.": {
    "_translate": "获取一个选区的 <a href=\"#state.SelectionBookmark\">bookmark</a>，它是一个无需访问当前 document 即可被 mapped 然后再在 mapped 后通过给定一个 document 再解析成一个真实选区的值。（这个方法最可能被用在 history 中，以进行 选区追踪和恢复旧选区）该方法的默认实现仅仅是转换当前选区为一个文本选区，然后返回文本选区的 bookmark。",
    "_note": ""
  },
  "Controls whether, when a selection of this type is active in the browser, the selected range should be visible to the user. Defaults to true.": {
    "_translate": "控制该选区类型在浏览器中被激活的时候是否对用户可见。默认是 <code>true</code>。",
    "_note": ""
  },
  "Find a valid cursor or leaf node selection starting at the given position and searching back if dir is negative, and forward if positive. When textOnly is true, only consider cursor selections. Will return null when no valid selection position is found.": {
    "_translate": "在给定的位置寻找一个可用的光标或叶节点选区，如果 <code>dir</code> 参数是负的则往左寻找，如果是正的则向右寻找。当 <code>textOnly</code> 是 true 的时候，则只考虑光标选区。 如果没有可用的选区位置，则返回 null。",
    "_note": "此方法对在粘贴或者一番操作后，不知道应该将光标放到哪个合适的位置时的情况尤为有用，它会自动寻找一个合适的位置，而不用手动 setSelection，对此种情况还有用的一个方法是下面的 near 方法。"
  },
  "Find a valid cursor or leaf node selection near the given position. Searches forward first by default, but if bias is negative, it will search backwards first.": {
    "_translate": "在给定的位置寻找一个可用的光标或者叶节点选区。默认向右搜索，如果 <code>bias</code> 是负，则会优先向左搜索。",
    "_note": ""
  },
  "Find the cursor or leaf node selection closest to the start of the given document. Will return an AllSelection if no valid position exists.": {
    "_translate": "寻找一个给定文档最开始的光标或叶节点选区。如果没有可用的位置存在，则返回 <a href=\"#state.AllSelection\"><code>AllSelection</code></a>。",
    "_note": ""
  },
  "Find the cursor or leaf node selection closest to the end of the given document.": {
    "_translate": "寻找一个给定文档最末尾的光标或者叶节点选区。",
    "_note": ""
  },
  "Deserialize the JSON representation of a selection. Must be implemented for custom classes (as a static class method).": {
    "_translate": "反序列化一个选区的 JSON 表示。必须在自定义的 selection 类中实现该方法（作为一个静态类方法）。",
    "_note": ""
  },
  "To be able to deserialize selections from JSON, custom selection classes must register themselves with an ID string, so that they can be disambiguated. Try to pick something that's unlikely to clash with classes from other modules.": {
    "_translate": "为了能够从 JSON 中反序列化一个选区，自定义的 selection 类必须用一个字符串 ID 来注册自己，以消除歧义。 尽量要用一个不会与其他模块的类名冲突的字符串。",
    "_note": ""
  },
  "A text selection represents a classical editor selection, with a head (the moving side) and anchor (immobile side), both of which point into textblock nodes. It can be empty (a regular cursor position).": {
    "_translate": "一个文本选区代表一个典型的编辑器选区，其有一个 head（移动的一侧）和一个 anchor（不动的一侧），二者都 指向一个文本块节点。它可以是空的（此时表示一个正常的光标位置）。",
    "_note": "文本块节点，即文本节点的直接父节点。如定义了 doc > p > text，则文本块节点即 p 节点。"
  },
  "Construct a text selection between the given points.": {
    "_translate": "构造一个包含给定两点的文本选区。",
    "_note": ""
  },
  "Returns a resolved position if this is a cursor selection (an empty text selection), and null otherwise.": {
    "_translate": "如果当前选区是一个光标选区（一个空的文本选区），则返回其 resolved 过的位置，否则返回 null。",
    "_note": ""
  },
  "Create a text selection from non-resolved positions.": {
    "_translate": "用一个非 resolved 过的位置作为参数来创建一个文本选区。",
    "_note": ""
  },
  "Return a text selection that spans the given positions or, if they aren't text positions, find a text selection near them. bias determines whether the method searches forward (default) or backwards (negative number) first. Will fall back to calling Selection.near when the document doesn't contain a valid text position.": {
    "_translate": "返回一个跨越给定 anchor 和 head 位置的选区，如果它们不是一个文本位置，则调用 findFrom 就近寻找一个可用的文本选区。 <code>bias</code> 决定就近向哪个方向寻找，默认是向左，值为负时是向右。如果文档不包含一个可用的文本位置， 则调用 <a href=\"#state.Selection%5Enear\"><code>Selection.near</code></a> 方法。",
    "_note": ""
  },
  "Create a node selection. Does not verify the validity of its argument.": {
    "_translate": "新建一个 node 选区。不会验证参数的可用性。",
    "_note": "因为不会验证参数的可用性，所以需要保证参数 $pos 是一个 resolved 过的可用 pos。"
  },
  "A node selection is a selection that points at a single node. All nodes marked selectable can be the target of a node selection. In such a selection, from and to point directly before and after the selected node, anchor equals from, and head equals to..": {
    "_translate": "一个 node （节点）选区是一个指向单独节点的选区。所有的配置为 <a href=\"#model.NodeSpec.selectable\">selectable</a> 的 node 节点都可以是一个 node 选区的目标。在这个类型的选区中，<code>from</code> 和 <code>to</code> 直接指向选择节点的前面和后面， <code>anchor</code> 等于 <code>from</code>，<code>head</code> 等于 <code>to</code>。",
    "_note": "node 选区就是当选中一个节点的时候的选区类型。"
  },
  "The selected node.": {
    "_translate": "当前选择的 node。",
    "_note": ""
  },
  "Create a node selection from non-resolved positions.": {
    "_translate": "以一个未 resolved 过的位置来新建一个 node 选区。",
    "_note": ""
  },
  "Determines whether the given node may be selected as a node selection.": {
    "_translate": "判断给的节点是否可以被选中作为一个 node 选区。",
    "_note": ""
  },
  "A selection type that represents selecting the whole document (which can not necessarily be expressed with a text selection, when there are for example leaf block nodes at the start or end of the document).": {
    "_translate": "代表了选中整个文档的选区类型（此时可能用文本选区类型来表示不是必要的，比如当一个文档开头或者结尾有一个叶节点的时候）。",
    "_note": ""
  },
  "Create an all-selection over the given document.": {
    "_translate": "创建一个覆盖给定文档的 AllSelection 选区类型。",
    "_note": ""
  },
  "Represents a selected range in a document.": {
    "_translate": "表示文档中的一个选区范围。",
    "_note": ""
  },
  "Create a range.": {
    "_translate": "创建一个选取。",
    "_note": ""
  },
  "The lower bound of the range.": {
    "_translate": "选区范围位置较小的一侧。",
    "_note": ""
  },
  "The upper bound of the range.": {
    "_translate": "选区范围位置较大的一侧。",
    "_note": ""
  },
  "A lightweight, document-independent representation of a selection. You can define a custom bookmark type for a custom selection class to make the history handle it well.": {
    "_translate": "一个轻量的，文档无关的选区形式。你可以对一个自定义选区类来自定义一个 bookmark 类型，使 history 正确处理它（自定义选区的 bookmark）。",
    "_note": ""
  },
  "Map the bookmark through a set of changes.": {
    "_translate": "在一系列的文档修改后 map 该 bookmark 到一个新的 bookmark。",
    "_note": ""
  },
  "Resolve the bookmark to a real selection again. This may need to do some error checking and may fall back to a default (usually TextSelection.between) if mapping made the bookmark invalid.": {
    "_translate": "将该 bookmark 再解析成一个真实选区。可能需要做一些错误检查，并且如果 mapping 后该 bookmark 变得不可用的话，则会回滚到 默认行为（通常是 <a href=\"#state.TextSelection%5Ebetween\"><code>TextSelection.between</code></a>）。",
    "_note": ""
  },
  "To make it easy to package and enable extra editor functionality, ProseMirror has a plugin system.": {
    "_translate": "为了让打包和扩展编辑器功能变得更容易，ProseMirror 提供了一个 Plugin 系统。",
    "_note": ""
  },
  "This is the type passed to the Plugin constructor. It provides a definition for a plugin.": {
    "_translate": "这是一个传递给 <a href=\"#state.Plugin\"><code>Plugin</code></a> 构造函数的类型。它提供了插件的配置。",
    "_note": ""
  },
  "The view props added by this plugin. Props that are functions will be bound to have the plugin instance as their this binding.": {
    "_translate": "该插件设置的 <a href=\"#view.EditorProps\">视图属性</a>。属性如果是函数，则函数的 <code>this</code> 将绑定到当前实例。",
    "_note": "对象属性是函数的话一般叫做对象的方法。"
  },
  "Allows a plugin to define a state field, an extra slot in the state object in which it can keep its own data.": {
    "_translate": "允许插件定义一个 <a href=\"#state.StateField\">state 字段</a>，一个在编辑器整体 state 对象上的额外的插槽，其可以持有自己的插件 state。",
    "_note": ""
  },
  "Can be used to make this a keyed plugin. You can have only one plugin with a given key in a given state, but it is possible to access the plugin's configuration and state through the key, without having access to the plugin instance object.": {
    "_translate": "可以被用来唯一确定一个 plugin。在一个给定的 state 你只能有一个给定 key 的 plugin。 你可以通过这个 key 而不用访问插件实例来访问该插件的配置和 state。",
    "_note": ""
  },
  "When the plugin needs to interact with the editor view, or set something up in the DOM, use this field. The function will be called when the plugin's state is associated with an editor view.": {
    "_translate": "当插件需要与编辑器视图交互的时候，或者需要在 DOM 上设置一些东西的时候，使用这个字段。 当插件的 state 与编辑器 view 有关联的时候将会调用该函数。",
    "_note": ""
  },
  "When present, this will be called before a transaction is applied by the state, allowing the plugin to cancel it (by returning false).": {
    "_translate": "如果有该函数，则该函数会在一个 transaction 被应用到 state 之前调用，以允许插件有机会取消该 transaction（通过返回 false）",
    "_note": ""
  },
  "Allows the plugin to append another transaction to be applied after the given array of transactions. When another plugin appends a transaction after this was called, it is called again with the new state and new transactions—but only the new transactions, i.e. it won't be passed transactions that it already saw.": {
    "_translate": "允许这个插件附加另一个 transaction 到将要被应用的 transactions 数组的末尾上去。 当另一个 plugin 又附加了一个 transaction 且其在当前 plugin 之后调用， 则当前 plugin 的该函数会再调用一次。但是仅含新的 transaction 和新的 state。也即是，它不会再将之前处理过的 transaction 再处理一次。",
    "_note": ""
  },
  "Additional properties are allowed on plugin specs, which can be read via Plugin.spec.": {
    "_translate": "插件规格允许附加属性，可以通过<a href=\"#state.Plugin.spec\"><code>Plugin.spec</code></a>读取。",
    "_note": ""
  },
  "A plugin spec may provide a state field (under its state property) of this type, which describes the state it wants to keep. Functions provided here are always called with the plugin instance as their this binding.": {
    "_translate": "插件可能会提供一个该配置类型的 state 字段（在它的 <a href=\"#state.PluginSpec.state\"><code>state</code></a> 属性上）。 它描述了插件想要持有的 state。该字段下的方法调用的时候，其 <code>this</code> 指向插件实例。",
    "_note": ""
  },
  "Initialize the value of the field. config will be the object passed to EditorState.create. Note that instance is a half-initialized state instance, and will not have values for plugin fields initialized after this one.": {
    "_translate": "初始化插件的 state。<code>config</code> 是传递给 <a href=\"#state.EditorState%5Ecreate\"><code>EditorState.create</code></a> 的对象。 记住：<code>instance</code> 是一个半初始化的 state 实例，在当前插件之后初始化的插件在此时将不会有值。",
    "_note": "因此在新建 state 的时候，插件的顺序至关重要。"
  },
  "Apply the given transaction to this state field, producing a new field value. Note that the newState argument is again a partially constructed state does not yet contain the state from plugins coming after this one.": {
    "_translate": "应用给定的 transaction 到插件的 state 字段，以产生一个新的 state。 记住，<code>newState</code> 参数再一次的，是一个部分构造的 state，它不会包含当前插件之后还未初始化的插件的 state。",
    "_note": ""
  },
  "Convert this field to JSON. Optional, can be left off to disable JSON serialization for the field.": {
    "_translate": "将当前字段值转换成 JSON。当然，你也可以留空以禁用当前插件 state 的序列化。",
    "_note": "所谓转成 JSON，在该文档所有对象的 toJSON 方法都是转成一个 plain object，而不是 JSON.stringify 得到的对象。"
  },
  "Deserialize the JSON representation of this field. Note that the state argument is again a half-initialized state.": {
    "_translate": "反序列化给定的该字段的 JSON 表示对象。记住：<code>state</code> 参数还是一个半序列化的 state 对象。",
    "_note": ""
  },
  "A stateful object that can be installed in an editor by a plugin.": {
    "_translate": "一个有状态的对象，可以通过<a href=\"#state.PluginSpec.view\">插件</a>安装在编辑器中。",
    "_note": ""
  },
  "Called whenever the view's state is updated.": {
    "_translate": "编辑器 view 一更新就调用该函数。",
    "_note": "编辑器 view 更新可能是用户的操作如输入内容，或者编辑器的操作，如由事件触发的 transaction 更新视图， 此处可以拿到编辑器的 view 和应用 transaction 之前的 state。"
  },
  "Called when the view is destroyed or receives a state with different plugins.": {
    "_translate": "当 state 对象被重新配置而不再含该插件或者编辑器视图被销毁的时候调用该函数。",
    "_note": "页面重载等情况会销毁编辑器的 view。"
  },
  "Plugins bundle functionality that can be added to an editor. They are part of the editor state and may influence that state and the view that contains it.": {
    "_translate": "Plugins 可以被添加到 editor 中，它们是 <a href=\"#state.EditorState\">编辑器 state</a> 的一部分，并且能够影响包含它的 state 和 view。",
    "_note": ""
  },
  "Create a plugin.": {
    "_translate": "创建一个 plugin。",
    "_note": ""
  },
  "The plugin's spec object.": {
    "_translate": "当前插件的 <a href=\"#state.PluginSpec\">配置对象</a>。",
    "_note": ""
  },
  "The props exported by this plugin.": {
    "_translate": "当前插件导出的 <a href=\"#view.EditorProps\">属性</a>",
    "_note": ""
  },
  "Extract the plugin's state field from an editor state.": {
    "_translate": "从编辑器的 state 上获取当前插件的 state。",
    "_note": ""
  },
  "A key is used to tag plugins in a way that makes it possible to find them, given an editor state. Assigning a key does mean only one plugin of that type can be active in a state.": {
    "_translate": "一个键用于<a href=\"#state.PluginSpec.key\">标记</a>插件，使得在给定的编辑器状态下可以找到它们。分配一个键意味着在一个状态中只能有一个该类型的插件处于活动状态。",
    "_note": ""
  },
  "Create a plugin key.": {
    "_translate": "新建一个 plugin key",
    "_note": ""
  },
  "Get the active plugin with this key, if any, from an editor state.": {
    "_translate": "用 key 从 state 获取到 key 对应的激活的插件。",
    "_note": ""
  },
  "Get the plugin's state from an editor state.": {
    "_translate": "从编辑器的 state 中获取插件的 state。",
    "_note": ""
  },
  "Make sure you load style/prosemirror.css as a stylesheet when using this module.": {
    "_translate": "确保在使用此模块时将<code>style/prosemirror.css</code>作为样式表加载。",
    "_note": ""
  },
  "ProseMirror's view module displays a given editor state in the DOM, and handles user events.": {
    "_translate": "ProseMirror 的视图模块在 DOM 中显示给定的 <a href=\"#state.EditorState\">编辑器状态</a>，并处理用户事件。",
    "_note": ""
  },
  "An editor view manages the DOM structure that represents an editable document. Its state and behavior are determined by its props.": {
    "_translate": "一个编辑器视图负责整个可编辑文档。它的 state 和行为由 props 决定。",
    "_note": "新建编辑器的第一步就是 new 一个 EditorView。"
  },
  "Create a view. place may be a DOM node that the editor should be appended to, a function that will place it into the document, or an object whose mount property holds the node to use as the document container. If it is null, the editor will not be added to the document.": {
    "_translate": "新建一个 view 视图，<code>place</code> 参数可能是一个 DOM 节点，表示编辑器的挂载点，或者一个函数，则编辑器将会被挂载在文档根节点 或者一个对象，它的 <code>mount</code> 属性的值表示编辑器的挂载 DOM，而如果是 <code>null</code>，编辑器将不会被放到文档中。",
    "_note": "place 是一个函数的时候，函数的参数是通过 document.createElement('div') 新建的一个 DOM 节点， 该节点将会作为函数的唯一参数传入，该节点还未被放入真实文档中，需要你手动放入。"
  },
  "The view's current state.": {
    "_translate": "编辑器当前的 <a href=\"#state.EditorState\">state</a>。",
    "_note": ""
  },
  "An editable DOM node containing the document. (You probably should not directly interfere with its content.)": {
    "_translate": "一个包含编辑器文档的可编辑 DOM 节点。（你不应该直接操作该节点的内容）",
    "_note": ""
  },
  "Indicates whether the editor is currently editable.": {
    "_translate": "指示当前编辑器是否 <a href=\"#view.EditorProps.editable\">可编辑</a>",
    "_note": ""
  },
  "When editor content is being dragged, this object contains information about the dragged slice and whether it is being copied or moved. At any other time, it is null.": {
    "_translate": "当编辑器的内容被拖拽的时候，这个对象包含有拖拽内容相关的信息及该内容是否被复制还是被移动。在其他时候，该对象是 null。",
    "_note": ""
  },
  "Holds true when a composition is active.": {
    "_translate": "当 <a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/IME_handling_guide\">composition</a> 事件触发的时候，该值为 true。",
    "_note": "composition 事件与 CJK 输入法有关，也与浏览器实现有关，Safari 和 Chrome 中的 composition 触发顺序就不一样，以及一些其他差异。 这导致了一些使用 ProseMirror 的编辑器在 Safari 上的表现比较诡异，论坛中也有很多针对 Safari 反馈的 bug，大多跟 composition 有关。"
  },
  "The view's current props.": {
    "_translate": "编辑器 view 的 <a href=\"#view.EditorProps\">props（属性）</a>。",
    "_note": "props 是一个 getter 属性，每次通过 view.props 访问到的 props 带的一定是最新的 state。"
  },
  "Update the view's props. Will immediately cause an update to the DOM.": {
    "_translate": "更新 view 的 props。将会立即引起 DOM 的更新。",
    "_note": ""
  },
  "Update the editor's state prop, without touching any of the other props.": {
    "_translate": "单独更新编辑器 props 的 <code>state</code> 属性。",
    "_note": ""
  },
  "Update the view by updating existing props object with the object given as argument. Equivalent to view.update(Object.assign({}, view.props, props)).": {
    "_translate": "用给定的参数来更新已有的 props 对象，以达到更新 view 的目的。等同于 <code>view.update(Object.assign({}, view.props, props))</code>。",
    "_note": ""
  },
  "Goes over the values of a prop, first those provided directly, then those from plugins given to the view, then from plugins in the state (in order), and calls f every time a non-undefined value is found. When f returns a truthy value, that is immediately returned. When f isn't provided, it is treated as the identity function (the prop value is returned directly).": {
    "_translate": "依次遍历一个 prop 的值，首先是直接提供的值，然后是视图中插件提供的值，再然后是状态中的插件提供的值（按顺序），每次找到非 undefined 的值时调用 <code>f</code>。当 <code>f</code> 返回一个真值时，立即返回该值。当未提供 <code>f</code> 时，将其视为恒等函数（直接返回 prop 值）。",
    "_note": "若提供了 f 函数，则 f 函数执行的时候，参数即为遍历到的 prop 的值（一般是个函数）， 若 f 函数返回了真值，则 someProp 函数的返回值即为 f 函数本身，并停止遍历；若 f 函数返回了非真值， 则继续遍历，直到遇到真值才返回。 若 f 函数未提供，则如果 prop 的值不为 undefined，则直接返回该值。"
  },
  "Query whether the view has focus.": {
    "_translate": "查询当前 view 是否被 focus。",
    "_note": ""
  },
  "Focus the editor.": {
    "_translate": "focus 编辑器。",
    "_note": "这个过程会用到特性检测，即检查 dom.focus({preventScroll: true}) 是否支持。"
  },
  "Get the document root in which the editor exists. This will usually be the top-level document, but might be a shadow DOM root if the editor is inside one.": {
    "_translate": "获取编辑器所在的根节点。通常情况下是顶级节点 <code>document</code>，但是也可能是一个 <a href=\"https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM\">shadow DOM</a> 根节点，如果编辑器在它内部的话。",
    "_note": ""
  },
  "When an existing editor view is moved to a new document or shadow tree, call this to make it recompute its root.": {
    "_translate": "当现有编辑器视图移动到新文档或影子树时，调用此函数以重新计算其根。",
    "_note": ""
  },
  "Given a pair of viewport coordinates, return the document position that corresponds to them. May return null if the given coordinates aren't inside of the editor. When an object is returned, its pos property is the position nearest to the coordinates, and its inside property holds the position of the inner node that the position falls inside of, or -1 if it is at the top level, not in any node.": {
    "_translate": "给定一对儿视口坐标信息，返回该坐标在文档中的位置。如果给定的坐标不在编辑器中，则会返回 null。 当返回一个对象时，<code>pos</code> 属性是离坐标最近的位置，<code>inside</code> 属性指示坐标落在的节点的内部节点的位置， 或者未为 -1，表示该坐标落在了顶级节点的位置，不在任何节点之内。",
    "_note": "inside 属性举例：如果 table 结构是 table > td+ > p* > text*，则若 pos 落在了 text 内部，则 inside 就是 text 开头的位置；如果落在了 p 之前的位置(before)，那就是 td 起始的位置(start)。"
  },
  "Returns the viewport rectangle at a given document position. left and right will be the same number, as this returns a flat cursor-ish rectangle. If the position is between two things that aren't directly adjacent, side determines which element is used. When < 0, the element before the position is used, otherwise the element after.": {
    "_translate": "返回给定文档位置的相对于视口的坐标及大小信息。<code>left</code> 和 <code>right</code> 总是相同，因为该函数返回的是一个光标的的位置和大小信息。 如果该位置在两个并不直接相邻的元素之间，则 <code>side</code> 参数决定了这两个元素哪个元素被使用，当 <code>side</code> 小于 0 的时候，使用位置前面（左边）的元素，否则是后面的元素。",
    "_note": "光标只有高度没有宽度，因此只有 top 和 bottom 及 height 信息；left 和 right 总是一样的，width 总是 0."
  },
  "Note that you should not mutate the editor's internal DOM, only inspect it (and even that is usually not necessary).": {
    "_translate": "记住：你 <strong>绝对不应该</strong> 直接修改编辑器内部的 DOM，而只能查看它（虽然即使是检查它也是不必要的）",
    "_note": "查看它 的意思是只能获取 DOM 的信息，而不要设置。"
  },
  "Find the DOM position that corresponds to the given document position. When side is negative, find the position as close as possible to the content before the position. When positive, prefer positions close to the content after the position. When zero, prefer as shallow a position as possible.": {
    "_translate": "返回给定位置的 DOM 节点。如果 <code>side</code> 参数是负的，则寻找离 position 最近的前面（左边的元素） 否则就寻找离位置最近的右边的元素。如果是 0，则会更倾向于返回一个较浅（？）的位置。",
    "_note": ""
  },
  "Find the DOM node that represents the document node after the given position. May return null when the position doesn't point in front of a node or if the node is inside an opaque node view.": {
    "_translate": "寻找给定位置的 DOM 节点。如果位置不指向一个 node 前面或者该 node 是一个不透明的 node view 的话，则返回 null。",
    "_note": ""
  },
  "This is intended to be able to call things like getBoundingClientRect on that DOM node. Do not mutate the editor DOM directly, or add styling this way, since that will be immediately overriden by the editor as it redraws the node.": {
    "_translate": "该方法设计的目的是让你能够在 DOM 上调用类似 <code>getBoundingClientRect</code> 方法。<strong>绝对不要</strong> 直接修改编辑器的 DOM 元素，也不要通过这种方式添加样式之类的，因为你的修改可能随着节点的重绘被立即覆盖掉。",
    "_note": "domAtPos 获取的是给定位置的 DOM 宽高和坐标信息，nodeDOM 获取的是给定位置的 DOM。你可以通过 nodeDOM 获取到 DOM 后再手动获取位置信息。"
  },
  "Find the document position that corresponds to a given DOM position. (Whenever possible, it is preferable to inspect the document structure directly, rather than poking around in the DOM, but sometimes—for example when interpreting an event target—you don't have a choice.)": {
    "_translate": "返回给定 DOM 的位置信息。（它会尽可能的优先选择直接检查文档结构来获取位置信息，而不是用四处寻找逐个探测的方式，但是有些情况下，比如给定的是一个事件 target，那你别无选择只能逐个 target 的进行测试）",
    "_note": "这句话的意思是，如果你直接通过 ProseMirror 的接口，如 nodeDOM，通过 pos 获取到了 DOM，然后通过该方法相当于是一个逆过程，以获取到 pos。然而，如果你传给该函数的参数是来自于 event.target 那么 ProseMirror 只能通过挨个节点检查的方式，来确定它在 ProseMirror 的位置。"
  },
  "The bias parameter can be used to influence which side of a DOM node to use when the position is inside a leaf node.": {
    "_translate": "如果位置落在了一个叶子节点，那么 <code>bias</code> 参数可以用来决定使用叶子节点的哪一侧。",
    "_note": "bias > 0 是右侧，否则是左侧，默认是左侧。"
  },
  "Find out whether the selection is at the end of a textblock when moving in a given direction. When, for example, given \"left\", it will return true if moving left from the current cursor position would leave that position's parent textblock. Will apply to the view's current state by default, but it is possible to pass a different state.": {
    "_translate": "返回如果光标往给定方向移动的话，当前光标是否是一个文本 block 的末尾。例如，当给定方向为 <code>「left」</code> 的话，如果光标向左移动一个单位的距离将会离开文本 block，则会返回 true。 默认使用的是view 当前的 state，也可以传入一个不同的 state。",
    "_note": "文本 block，一般情况下指的是 paragraph 这种的，以 text 为直接子元素的节点。该方法的移动给定方向后检测的位置是 state.selection.$head。"
  },
  "Run the editor's paste logic with the given HTML string. The event, if given, will be passed to the handlePaste hook.": {
    "_translate": "运行编辑器的粘贴逻辑与给定的HTML字符串。 如果给定，<code>event</code> 将被传递到 <a href=\"#view.EditorProps.handlePaste\"><code>handlePaste</code></a> 钩子。",
    "_note": ""
  },
  "Run the editor's paste logic with the given plain-text input.": {
    "_translate": "运行编辑器的粘贴逻辑与给定的纯文本输入。",
    "_note": ""
  },
  "Removes the editor from the DOM and destroys all node views.": {
    "_translate": "从 DOM 中移除编辑器，并销毁所有的 <a href=\"#view.NodeView\">node views</a>。",
    "_note": ""
  },
  "This is true when the view has been destroyed (and thus should not be used anymore).": {
    "_translate": "这是真的，当视图已经 <a href=\"#view.EditorView.destroy\">销毁</a>（因此不应再使用）。",
    "_note": ""
  },
  "Used for testing.": {
    "_translate": "用于测试。",
    "_note": ""
  },
  "Dispatch a transaction. Will call dispatchTransaction when given, and otherwise defaults to applying the transaction to the current state and calling updateState with the result. This method is bound to the view instance, so that it can be easily passed around.": {
    "_translate": "派发一个 transaction。会调用 <a href=\"#view.DirectEditorProps.dispatchTransaction\"><code>dispatchTransaction</code></a> （如果设置了的话），否则默认应用该 transaction 到当前 state， 然后将其结果（新的 state）作为参数，传入 <a href=\"#view.EditorView.updateState\"><code>updateState</code></a> 方法。该方法被绑定在 view 对象上，因此可以容易地被调用。",
    "_note": "必须调用 view.dispatch(transaction) 才可以触发一个更改。该方法一般情况下用在事件响应函数里面，但是你也可以用在任何能访问到 view 的地方。 反过来说，比如在 plugin 的 state 的 apply 内，你访问不到 view，也就不能 dispatch 一个 tr。如果你强行在其内 dispatch 了一个 tr（如通过将 view 放到 window 作为全局访问的方法），那么会导致循环调用以致内存溢出。"
  },
  "Props are configuration values that can be passed to an editor view or included in a plugin. This interface lists the supported props.": {
    "_translate": "Props 就是一些可以传递给编辑器的 view，或者用在插件中的值。这个接口列出了支持的 props。",
    "_note": ""
  },
  "The various event-handling functions may all return true to indicate that they handled the given event. The view will then take care to call preventDefault on the event, except with handleDOMEvents, where the handler itself is responsible for that.": {
    "_translate": "不同的事件处理函数可能都返回 <code>true</code> 表示它们处理了相应的事件。view 将会在事件发生时帮你调用 <code>preventDefault</code>。但是 <code>handleDOMEvents</code> 中的事件需要你负责去手动调用。",
    "_note": ""
  },
  "How a prop is resolved depends on the prop. Handler functions are called one at a time, starting with the base props and then searching through the plugins (in order of appearance) until one of them returns true. For some props, the first plugin that yields a value gets precedence.": {
    "_translate": "不同的 prop 有不同的处理方式。prop 是函数的话则会在某个时刻调用：最开始的时候是寻找在 view 上的 prop，然后按照 plugin 书写的顺序查找其上的 prop，按顺序调用，直到它们中的某一个返回了 true 才终止。 而对于其他一些 porps，会使用遇到的第一个 prop 返回的值。",
    "_note": ""
  },
  "The optional type parameter refers to the type of this in prop functions, and is used to pass in the plugin type when defining a plugin.": {
    "_translate": "可选类型参数指的是 prop 函数中 <code>this</code> 的类型，并在定义<a href=\"#state.Plugin\">插件</a>时用于传入插件类型。",
    "_note": ""
  },
  "Can be an object mapping DOM event type names to functions that handle them. Such functions will be called before any handling ProseMirror does of events fired on the editable DOM element. Contrary to the other event handling props, when returning true from such a function, you are responsible for calling preventDefault yourself (or not, if you want to allow the default behavior).": {
    "_translate": "其是一个对象，键是 DOM 事件名，值是事件处理函数。事件处理函数将会先于 ProseMirror 处理任何发生在可编辑 DOM 元素上的事件之前调用。 与其他事件处理函数（此处指的是下面这些 ProseMirror 自己的事件处理函数）相反的是，当该函数返回 true 的时候，你需要手动调用 <code>preventDefault</code>（或者不调用，如果你想允许默认行为发生的话）",
    "_note": "可以理解为，handleDOMEvents 中定义的事件比较原始，一切都需要你自己来掌控。之所以其内定义的事件处理函数会发生于 ProseMirror 事件处理之前，一个原因我猜是因为 如果 ProseMirror 事件处理完了之后再调用用户定义的事件处理函数，则需要再处理一遍 DOM 的更新。"
  },
  "Called when the editor receives a keydown event.": {
    "_translate": "当编辑器接收到一个 <code>keydown</code> 事件的时候调用。",
    "_note": ""
  },
  "Handler for keypress events.": {
    "_translate": "当编辑器接收到一个 <code>keypress</code> 事件的时候调用。",
    "_note": ""
  },
  "Whenever the user directly input text, this handler is called before the input is applied. If it returns true, the default behavior of actually inserting the text is suppressed.": {
    "_translate": "无论何时用户直接输入了文字的时候，该处理函数将会在输入内容应用到 DOM 之前调用。如果该函数返回 <code>true</code>，则用户输入文本到编辑器的默认行为将会被阻止。",
    "_note": "该方法通常用来拦截输入，然后生成新的输入，如自动转换 markdown 语法，或者按下某个键执行特殊操作的时候比较有用。"
  },
  "Called for each node around a click, from the inside out. The direct flag will be true for the inner node.": {
    "_translate": "为每一个点击事件冒泡路径上的节点从内到外都调用一遍该函数。如果是内部节点，则 <code>direct</code> 将会是 true。",
    "_note": ""
  },
  "Called for each node around a double click.": {
    "_translate": "同<code>handleClickOn</code>，只是针对双击事件。",
    "_note": ""
  },
  "Called when the editor is clicked, after handleClickOn handlers have been called.": {
    "_translate": "当编辑器被点击的时候调用，函数执行顺序位于 <code>handleClickOn</code> 函数之后。",
    "_note": ""
  },
  "Called when the editor is double-clicked, after handleDoubleClickOn.": {
    "_translate": "同 <code>handleClick</code> 只是针对双击事件。",
    "_note": ""
  },
  "Called for each node around a triple click.": {
    "_translate": "同<code>handleClickOn</code>，只是针对三击事件。",
    "_note": ""
  },
  "Called when the editor is triple-clicked, after handleTripleClickOn.": {
    "_translate": "同 <code>handleClick</code> 只是针对三击事件",
    "_note": ""
  },
  "Can be used to override the behavior of pasting. slice is the pasted content parsed by the editor, but you can directly access the event to get at the raw content.": {
    "_translate": "可以用来覆盖默认的粘贴行为。<code>slice</code> 是被编辑器格式化后的粘贴内容，不过你也可以通过直接访问事件对象来获取原始的粘贴内容。",
    "_note": "粘贴事件中的数据位于 event.dataTransfer 对象上。"
  },
  "Called when something is dropped on the editor. moved will be true if this drop moves from the current selection (which should thus be deleted).": {
    "_translate": "当有东西被放入编辑器的时候调用。如果是从当前编辑器选区放入的，则 <code>moved</code> 参数会是 true（因此选区的内容应该被删除）。",
    "_note": ""
  },
  "Called when the view, after updating its state, tries to scroll the selection into view. A handler function may return false to indicate that it did not handle the scrolling and further handlers or the default behavior should be tried.": {
    "_translate": "当 view 更新了 state 之后，尝试将选区滚动到视图中的时候调用该函数。该函数可能返回 false，表示它不处理滚动；或者返回 true，表示让默认行为发生。",
    "_note": ""
  },
  "Can be used to override the way a selection is created when reading a DOM selection between the given anchor and head.": {
    "_translate": "在给定的起点和终点新建一个选区。",
    "_note": ""
  },
  "The parser to use when reading editor changes from the DOM. Defaults to calling DOMParser.fromSchema on the editor's schema.": {
    "_translate": "<a href=\"#model.DOMParser\">parser</a> 用来从 DOM 中读取编辑器的变化。默认情况下（如果不设置的话）调用 <a href=\"#model.DOMParser%5EfromSchema\"><code>DOMParser.fromSchema</code></a> 方法，参数是编辑器的 schema。",
    "_note": ""
  },
  "Can be used to transform pasted HTML text, before it is parsed, for example to clean it up.": {
    "_translate": "可以被用来在 HTML 文本被 parser <em>之前</em> 转换一下。",
    "_note": ""
  },
  "The parser to use when reading content from the clipboard. When not given, the value of the domParser prop is used.": {
    "_translate": "用来从粘贴板中读取内容后 <a href=\"#model.DOMParser\">parser</a> 。如果没有给，则使用 <a href=\"#view.EditorProps.domParser\"><code>domParser</code></a> 属性。",
    "_note": ""
  },
  "Transform pasted plain text. The plain flag will be true when the text is pasted as plain text.": {
    "_translate": "转换粘贴的纯文本。如果粘贴的文本是纯文本的话，<code>plain</code> 将会是 true。",
    "_note": ""
  },
  "A function to parse text from the clipboard into a document slice. Called after transformPastedText. The default behavior is to split the text into lines, wrap them in <p> tags, and call clipboardParser on it. The plain flag will be true when the text is pasted as plain text.": {
    "_translate": "将粘贴板中的文本 parse 成文档 slice。将会在 <a href=\"#view.EditorProps.transformPastedText\"><code>transformPastedText</code></a> 之后调用。 默认行为是将文本分割成多行，然后使用 <code>&lt;p&gt;</code> 标签包裹之，然后再对其调用 [clipboardParser<code>](#view.EditorProps.clipboardParser)。如果粘贴的内容是纯文本，则</code>plain` 将会是 true。",
    "_note": ""
  },
  "Can be used to transform pasted or dragged-and-dropped content before it is applied to the document.": {
    "_translate": "可用于在粘贴或拖放内容之前对其进行转换，然后再应用到文档中。",
    "_note": ""
  },
  "Can be used to transform copied or cut content before it is serialized to the clipboard.": {
    "_translate": "可用于在内容被序列化到剪贴板之前转换复制或剪切的内容。",
    "_note": ""
  },
  "decorations is an array of node or inline decorations that are active around the node. They are automatically drawn in the normal way, and you will usually just want to ignore this, but they can also be used as a way to provide context information to the node view without adding it to the document itself.": {
    "_translate": "<code>decoration</code> 是一个在当前 node 周围激活的 node decoration 或者 inline decoration 数组。 他们会自动绘制，通常情况下你可以忽略它们，不过它们也可以用来为 node view 提供上下文信息，而不是将它们添加到文档中。",
    "_note": "最后一句话的意思是，在 plugin.props 的 decoration 属性上，你可以通过构造 decoration 的时候添加一些额外的信息，然后在 node view 中拿到这些信息来搞事情。"
  },
  "innerDecorations holds the decorations for the node's content. You can safely ignore this if your view has no content or a contentDOM property, since the editor will draw the decorations on the content. But if you, for example, want to create a nested editor with the content, it may make sense to provide it with the inner decorations.": {
    "_translate": "<code>innerDecorations</code> 指向节点内容的装饰器。如果你的 view 没有内容或者没有 <code>contentDOM</code> 属性的话，你可以安全的忽略它，因为 编辑器将会把该 decorations 绘制到其内容上。不过如果你的 view 有内容，比如，用该内容创建一个嵌套的 editor，那么提供给其内部元素的内部 decorations 就是有用的。",
    "_note": "这个 innerDecorations 是新增的参数，之前是没有这个参数的，可以看下原仓库的修改记录。"
  },
  "Allows you to pass custom rendering and behavior logic for nodes. Should map node names to constructor functions that produce a NodeView object implementing the node's display behavior. The third argument getPos is a function that can be called to get the node's current position, which can be useful when creating transactions to update it. Note that if the node is not in the document, the position returned by this function will be undefined.": {
    "_translate": "允许您为节点传递自定义渲染和行为逻辑。应将节点名称映射到生成实现节点显示行为的<a href=\"#view.NodeView\"><code>NodeView</code></a>对象的构造函数。第三个参数<code>getPos</code>是一个可以调用以获取节点当前位置的函数，这在创建transaction以更新节点时非常有用。请注意，如果节点不在文档中，此函数返回的位置将是<code>undefined</code>。",
    "_note": ""
  },
  "(For backwards compatibility reasons, mark views can also be included in this object.)": {
    "_translate": "(出于向后兼容性的原因，<a href=\"#view.EditorProps.markViews\">标记视图</a>也可以包含在此对象中。)",
    "_note": ""
  },
  "Pass custom mark rendering functions. Note that these cannot provide the kind of dynamic behavior that node views can—they just provide custom rendering logic. The third argument indicates whether the mark's content is inline.": {
    "_translate": "传递自定义标记渲染函数。请注意，这些不能提供<a href=\"#view.NodeView\">节点视图</a>可以提供的那种动态行为——它们只是提供自定义渲染逻辑。第三个参数表示标记的内容是否为内联。",
    "_note": ""
  },
  "The DOM serializer to use when putting content onto the clipboard. If not given, the result of DOMSerializer.fromSchema will be used. This object will only have its serializeFragment method called, and you may provide an alternative object type implementing a compatible method.": {
    "_translate": "用于将内容放入剪贴板的DOM序列化器。如果未提供，将使用 <a href=\"#model.DOMSerializer%5EfromSchema\"><code>DOMSerializer.fromSchema</code></a> 的结果。此对象将仅调用其 <a href=\"#model.DOMSerializer.serializeFragment\"><code>serializeFragment</code></a> 方法，您可以提供实现兼容方法的替代对象类型。",
    "_note": ""
  },
  "A function that will be called to get the text for the current selection when copying text to the clipboard. By default, the editor will use textBetween on the selected range.": {
    "_translate": "当复制内容到粘贴板的时候，该方法将会被调用以用来获取选区内的文本。默认情况下，编辑器会在选区范围使用 <a href=\"#model.Node.textBetween\"><code>textBetween</code></a> 方法。",
    "_note": ""
  },
  "A set of document decorations to show in the view.": {
    "_translate": "一个展示在 view 上的 <a href=\"#view.Decoration\">document decorations（文档装饰器）</a> 集合。",
    "_note": "之前该方法返回 DecorationSet，现在返回 DecorationSource，有兴趣的可以研究下区别。"
  },
  "When this returns false, the content of the view is not directly editable.": {
    "_translate": "当它返回 false，那么 view 的内容不能直接编辑。",
    "_note": "不能直接编辑的意思就是用户不能将光标放入进去，然后编辑。但是仍然可以通过 dispatch transaction 进行编辑。"
  },
  "Control the DOM attributes of the editable element. May be either an object or a function going from an editor state to an object. By default, the element will get a class \"ProseMirror\", and will have its contentEditable attribute determined by the editable prop. Additional classes provided here will be added to the class. For other attributes, the value provided first (as in someProp) will be used.": {
    "_translate": "控制可编辑元素上的 DOM attributes。可以是一个对象，或者是一个函数接收编辑器的 state，然后返回一个对象。 默认情况下，元素将会被设置一个 <code>「ProseMirror」</code> 类名，以及一个由 <a href=\"#view.EditorProps.editable\"><code>editable</code> prop</a> 决定的 <code>contentEditable</code> attributes。 在此处提供的其他类名将会被附加上去。对于其他 attributes，最先提供的将会被使用（就像 <a href=\"#view.EditorView.someProp\"><code>someProp</code></a> 一样）。",
    "_note": "原文中的 prop 和 attribute 我个人觉得应该分开翻译而不能都翻译成 属性，但是找不到合适的中文进行区分， 部分翻译资料（如上古时期的 jQuery），将 attr 和 prop 分别翻译成「属性」和「特性」，在此处感觉也不是很妥当，因此索性不翻译了。"
  },
  "Determines the distance (in pixels) between the cursor and the end of the visible viewport at which point, when scrolling the cursor into view, scrolling takes place. Defaults to 0.": {
    "_translate": "当滚动光标位置到视口的时候，决定光标与视口尾部的距离（单位是像素）多大才开始滚动。默认是 0。",
    "_note": ""
  },
  "Determines the extra space (in pixels) that is left above or below the cursor when it is scrolled into view. Defaults to 5.": {
    "_translate": "当光标滚动到视口中的时候，决定光标离视口上下方的距离，默认是 5（像素为单位）。",
    "_note": ""
  },
  "The type of function provided to create node views.": {
    "_translate": "提供用于创建<a href=\"#view.NodeView\">节点视图</a>的<a href=\"#view.EditorProps.nodeViews\">函数类型</a>。",
    "_note": ""
  },
  "The function types used to create mark views.": {
    "_translate": "函数类型<a href=\"#view.EditorProps.markViews\">用于</a>创建标记视图。",
    "_note": ""
  },
  "The props object given directly to the editor view supports some fields that can't be used in plugins:": {
    "_translate": "直接提供给编辑器视图的props对象支持一些不能在插件中使用的字段：",
    "_note": ""
  },
  "The current state of the editor.": {
    "_translate": "编辑器当前的 state。",
    "_note": "plugin 有自己的 state 字段，其与 props 平级，因此不作为 props 的属性。"
  },
  "A set of plugins to use in the view, applying their plugin view and props. Passing plugins with a state component (a state field field or a transaction filter or appender) will result in an error, since such plugins must be present in the state to work.": {
    "_translate": "一组在视图中使用的插件，应用它们的<a href=\"#state.PluginSpec.view\">插件视图</a>和<a href=\"#state.PluginSpec.props\">属性</a>。传递带有状态组件（<a href=\"#state.PluginSpec.state\">状态字段</a>或<a href=\"#state.PluginSpec.filterTransaction\">transaction</a>过滤器或附加器）的插件将导致错误，因为此类插件必须存在于状态中才能工作。",
    "_note": ""
  },
  "The callback over which to send transactions (state updates) produced by the view. If you specify this, you probably want to make sure this ends up calling the view's updateState method with a new state that has the transaction applied. The callback will be bound to have the view instance as its this binding.": {
    "_translate": "view dispatch 一个 transaction 后（更新 state 前），transaction 会先经过此回调函数。 如果你设置了该函数，你应该需要保证该函数以调用 view 的 <a href=\"#view.EditorView.updateState\"><code>updateState</code></a> 方法结束。 <code>updateState</code> 方法接受一个 <a href=\"#state.EditorState.apply\">applied</a> 过该 transaction 的 state 作为参数。回调的 <code>this</code> 绑定到 view 实例上。",
    "_note": ""
  },
  "By default, document nodes are rendered using the result of the toDOM method of their spec, and managed entirely by the editor. For some use cases, such as embedded node-specific editing interfaces, you want more control over the behavior of a node's in-editor representation, and need to define a custom node view.": {
    "_translate": "默认情况下，文档节点使用它们 schema 配置对象中的 <a href=\"#model.NodeSpec.toDOM\"><code>toDOM</code></a> 方法来渲染，然后完全由编辑器管理状态。而对于一些使用场景，比如为特定节点嵌入编辑界面等情况， 你可能想要更加细粒度的控制一个节点在编辑器中的表现形式，因此，你需要 <a href=\"#view.EditorProps.nodeViews\">define</a> 一个自定义的 node view。",
    "_note": ""
  },
  "Mark views only support dom and contentDOM, and don't support any of the node view methods.": {
    "_translate": "Mark 的 view 仅仅支持 <code>dom</code> 和 <code>contentDOM</code>，而且不支持任何 node view 的方法。",
    "_note": ""
  },
  "Objects returned as node views must conform to this interface.": {
    "_translate": "node views 们返回的对象必须保证有以下接口：",
    "_note": ""
  },
  "The outer DOM node that represents the document node.": {
    "_translate": "表示文档节点的外部DOM节点。",
    "_note": ""
  },
  "The DOM node that should hold the node's content. Only meaningful if the node view also defines a dom property and if its node type is not a leaf node type. When this is present, ProseMirror will take care of rendering the node's children into it. When it is not present, the node view itself is responsible for rendering (or deciding not to render) its child nodes.": {
    "_translate": "应该持有节点的内容的 DOM 节点。只有当定义了 <code>dom</code> 属性且节点类型不是叶子节点的时候才有意义。 当它设置的时候，ProseMirror 将会将节点的子节点渲染到该 DOM 中作为它的子节点； 如果没有设置，node view 本身有责任渲染（或者决定不渲染）它的子节点。",
    "_note": ""
  },
  "Can be used to override the way the node's selected status (as a node selection) is displayed.": {
    "_translate": "可以用来覆盖节点选中的展示状态（作为一个节点选区）。",
    "_note": ""
  },
  "When given, this will be called when the view is updating itself. It will be given a node (possibly of a different type), an array of active decorations around the node (which are automatically drawn, and the node view may ignore if it isn't interested in them), and a decoration source that represents any decorations that apply to the content of the node (which again may be ignored). It should return true if it was able to update to that node, and false otherwise. If the node view has a contentDOM property (or no dom property), updating its child nodes will be handled by ProseMirror.": {
    "_translate": "当 node view 更新自身的时候会调用该节点的此方法。它接受一个 node（可能是与当前不同的类型）、 一个激活的 decorations 数组（它会自行渲染，如果 node view 对它的新的不感兴趣的话可以忽略）作为参数。 如果 node 需要被更新，则返回 true，否则返回 false。如果 node view 有一个 <code>contentDOM</code> 属性（或者 <code>dom</code> 属性），则它的子节点的更新将交给 ProseMirror 来控制。",
    "_note": ""
  },
  "When defining a selectNode method, you should also provide a deselectNode method to remove the effect again.": {
    "_translate": "当定义一个 <code>selectNode</code> 方法，你应该同时提供一个 <code>deselectNode</code> 方法去移除前者所做的效果。",
    "_note": ""
  },
  "This will be called to handle setting the selection inside the node. The anchor and head positions are relative to the start of the node. By default, a DOM selection will be created between the DOM positions corresponding to those positions, but if you override it you can do something else.": {
    "_translate": "该方法将会被调用以用来处理节点内部选区的设置。<code>anchor</code> 和 <code>head</code> 位置相对于节点的起始位置。 默认情况下，将会在与这些位置相对应的 DOM 位置之间创建 DOM 选区，不过你可以通过覆盖该行为来做一些其他的事情。",
    "_note": ""
  },
  "Can be used to prevent the editor view from trying to handle some or all DOM events that bubble up from the node view. Events for which this returns true are not handled by the editor.": {
    "_translate": "可以用来阻止编辑器处理一些或者所有的源自 node view 的 DOM 事件。返回 true 表示编辑器不处理该事件。",
    "_note": ""
  },
  "Called when a DOM mutation or a selection change happens within the view. When the change is a selection change, the record will have a type property of \"selection\" (which doesn't occur for native mutation records). Return false if the editor should re-read the selection or re-parse the range around the mutation, true if it can safely be ignored.": {
    "_translate": "当一个 DOM <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver\">mutation（突变）</a> 的时候调用，或者在 node view 内一个选区改变的时候调用。当是选区改变的时候，record 将会有一个值为 <code>「selection」</code> 的 <code>type</code> 属性（原生的 mutation records 没有）。返回 false 表示编辑器应该重新读取选区或者重新 parse 突变附近的 DOM， 返回 true 表示该突变可以被安全的忽略掉。",
    "_note": ""
  },
  "Called when the node view is removed from the editor or the whole editor is destroyed. (Not available for marks.)": {
    "_translate": "当整个编辑器被销毁或者当前 node view 被移除的时候调用（对 marks 的 view 不可用）。",
    "_note": ""
  },
  "Helper type that maps event names to event object types, but includes events that TypeScript's HTMLElementEventMap doesn't know about.": {
    "_translate": "帮助器类型将事件名称映射到事件对象类型，但包括 TypeScript 的 HTMLElementEventMap 不知道的事件。",
    "_note": ""
  },
  "Decorations make it possible to influence the way the document is drawn, without actually changing the document.": {
    "_translate": "装饰使得可以在不实际更改文档的情况下影响文档的绘制方式。",
    "_note": ""
  },
  "Decoration objects can be provided to the view through the decorations prop. They come in several variants—see the static members of this class for details.": {
    "_translate": "Decoration（装饰器）对象可以通过 <a href=\"#view.EditorProps.decorations\"><code>decoration</code> 属性</a>提供给 view。 它们有多个不同的变体，有关的详细信息，参见此类的静态成员。",
    "_note": "Decoration 有三种，widget 挂件装饰器；inline 行内装饰器；node 节点装饰器；"
  },
  "The start position of the decoration.": {
    "_translate": "decoration 开始的位置",
    "_note": ""
  },
  "The end position. Will be the same as from for widget decorations.": {
    "_translate": "decoration 结束的位置。如果是 <a href=\"#view.Decoration%5Ewidget\">widget decorations</a> 的话，该值将会和 <code>from</code> 一致。",
    "_note": ""
  },
  "The spec provided when creating this decoration. Can be useful if you've stored extra information in that object.": {
    "_translate": "当创建 decoration 的时候提供的配置。用来存储一些额外的信息非常有用。",
    "_note": ""
  },
  "Creates a widget decoration, which is a DOM node that's shown in the document at the given position. It is recommended that you delay rendering the widget by passing a function that will be called when the widget is actually drawn in a view, but you can also directly pass a DOM node. getPos can be used to find the widget's current document position.": {
    "_translate": "创建一个 widget decorations，它是一个显示在给定位置的 DOM 节点。推荐的方式是通过传递一个函数来返回 decoration，以实现当该 decoration 绘制在 view 的时候延迟渲染的目的，不过你也可以直接传递一个 DOM 节点。<code>getPos</code> 方法用来获取 widget 在当前文档的位置。",
    "_note": ""
  },
  "Controls which side of the document position this widget is associated with. When negative, it is drawn before a cursor at its position, and content inserted at that position ends up after the widget. When zero (the default) or positive, the widget is drawn after the cursor and content inserted there ends up before the widget.": {
    "_translate": "控制该 widget 与文档位置的哪一侧相关。当是负数的时候，它绘制在给定位置光标的之前， 并且在该位置插入的内容在 widget 之后。当非负（默认）的时候，widget 绘制在给定位置光标之后，用户输入的内容会插入到该位置之前。",
    "_note": ""
  },
  "When there are multiple widgets at a given position, their side values determine the order in which they appear. Those with lower values appear first. The ordering of widgets with the same side value is unspecified.": {
    "_translate": "当在同一个位置有多个 widget 的时候，他们的 <code>side</code> 决定了它们出现的顺序。较小的值出现在前面。 相同 <code>side</code> 值的话先后位置不确定。",
    "_note": "相同 side 值 widget 出现的先后位置不确定，原因跟某些算法排序的 稳定 概念类似。"
  },
  "When marks is null, side also determines the marks that the widget is wrapped in—those of the node before when negative, those of the node after when positive.": {
    "_translate": "当 <code>marks</code> 是 null 的时候，<code>side</code> 同样决定 widget 包裹的 marks。节点之前的是负的，节点之后的是正的。",
    "_note": ""
  },
  "The precise set of marks to draw around the widget.": {
    "_translate": "绘制在 widget 周围的 marks。",
    "_note": ""
  },
  "Can be used to control which DOM events, when they bubble out of this widget, the editor view should ignore.": {
    "_translate": "可以用来控制编辑器应该忽略从 widget 冒泡出来的哪些 DOM 事件。",
    "_note": ""
  },
  "When set (defaults to false), selection changes inside the widget are ignored, and don't cause ProseMirror to try and re-sync the selection with its selection state.": {
    "_translate": "当设置的时候（默认是 false），在 widget 内的选区变化将被忽略， 这样的话该变化就不会让 ProseMirror 尝试重新同步该选区和 state 的选区。",
    "_note": ""
  },
  "Called when the widget decoration is removed or the editor is destroyed.": {
    "_translate": "在小部件装饰被移除或编辑器被销毁时调用。",
    "_note": ""
  },
  "When comparing decorations of this type (in order to decide whether it needs to be redrawn), ProseMirror will by default compare the widget DOM node by identity. If you pass a key, that key will be compared instead, which can be useful when you generate decorations on the fly and don't want to store and reuse DOM nodes. Make sure that any widgets with the same key are interchangeable—if widgets differ in, for example, the behavior of some event handler, they should get different keys.": {
    "_translate": "当比较此种类型的 decorations 的时候（以决定它是否应该被重绘），ProseMirror 将会默认通过 widget DOM 节点来识别。如果你传递了一个 key，那它就会用 key 来对比。 这对于你仅仅想在内存中创建 decorations 而不真正绘制 DOM 结构很有用。确保任何具有相同 key 的 widget 是可互换的--比如，如果 widget 的一些事件处理函数不一样，即使 DOM 结构相同，也应该有不同的 key。",
    "_note": ""
  },
  "Specs allow arbitrary additional properties.": {
    "_translate": "规格允许任意附加属性。",
    "_note": ""
  },
  "Creates an inline decoration, which adds the given attributes to each inline node between from and to.": {
    "_translate": "创建一个内联的 decoration，它会在 <code>from</code> 和 <code>to</code> 之间的每一个内联节点上添加给定的 attributes。",
    "_note": ""
  },
  "Determines how the left side of the decoration is mapped when content is inserted directly at that position. By default, the decoration won't include the new content, but you can set this to true to make it inclusive.": {
    "_translate": "决定如果内容直接插入在这个位置的时候，decoration 的左侧如何 <a href=\"#transform.Position_Mapping\">mapped</a>。 默认情况下，decoration 不会包括新的内容，不过你可以设置为 <code>true</code> 来让它影响新内容。",
    "_note": ""
  },
  "Determines how the right side of the decoration is mapped. See inclusiveStart.": {
    "_translate": "决定 decoration 的右侧如何被 mapped。具体看 <a href=\"#view.Decoration%5Einline%5Espec.inclusiveStart\"><code>inclusiveStart</code></a>。",
    "_note": ""
  },
  "Specs may have arbitrary additional properties.": {
    "_translate": "规格可能具有任意的附加属性。",
    "_note": ""
  },
  "Creates a node decoration. from and to should point precisely before and after a node in the document. That node, and only that node, will receive the given attributes.": {
    "_translate": "创建一个 node decoration。<code>from</code> 和 <code>to</code> 应该精确的指向在文档中的某个节点的前面和后面。该节点，也只有该节点，会受到给定的 attributes。",
    "_note": ""
  },
  "A set of attributes to add to a decorated node. Most properties simply directly correspond to DOM attributes of the same name, which will be set to the property's value. These are exceptions:": {
    "_translate": "一个被用来添加到被装饰的节点附近的 attributes 集合。大多数 properties 的名字与同名的 DOM attributes 一样，以用来被设置为属性值。下面几个是特例：",
    "_note": ""
  },
  "When non-null, the target node is wrapped in a DOM element of this type (and the other attributes are applied to this element).": {
    "_translate": "如果该值为非 null，则目标节点将会用该类型的节点包裹住（同时其他的属性会被应用到该元素上）。",
    "_note": ""
  },
  "A CSS class name or a space-separated set of class names to be added to the classes that the node already had.": {
    "_translate": "会被 <em>添加</em> 到节点已有的类名上的 CSS 的类名，或者用空格分隔的 css 类名集合。",
    "_note": ""
  },
  "A string of CSS to be added to the node's existing style property.": {
    "_translate": "会被 <em>添加</em> 到节点已有的 <code>style</code> 属性上的 CSS 字符串。",
    "_note": ""
  },
  "Any other properties are treated as regular DOM attributes.": {
    "_translate": "任何其他属性都被视为常规DOM属性。",
    "_note": ""
  },
  "A collection of decorations, organized in such a way that the drawing algorithm can efficiently use and compare them. This is a persistent data structure—it is not modified, updates create a new value.": {
    "_translate": "一个 <a href=\"#view.Decoration\">decorations</a> 集合，用这种数据结构组织它们可以让绘制算法高效的对比和渲染它们。 它是一个不可突变的数据结构，它不改变，更新会产生新的值。",
    "_note": ""
  },
  "Map the set of decorations in response to a change in the document.": {
    "_translate": "Map decorations 的集合以响应文档修改。",
    "_note": ""
  },
  "Find all decorations in this set which touch the given range (including decorations that start or end directly at the boundaries) and match the given predicate on their spec. When start and end are omitted, all decorations in the set are considered. When predicate isn't given, all decorations are assumed to match.": {
    "_translate": "找到给定范围涉及到的所有的 decoration 集合（包括开始或结束位置在边界的 decorations）， 然后用给定的 predicate 函数来检测是否匹配，该函数参数是 decoration 的配置对象。 若 <code>start</code> 和 <code>end</code> 省略，则集合中所有的 decoration 将会被检测。如果 <code>predicate</code> 没有给出，则所有的 decorations 将会 match。",
    "_note": ""
  },
  "When given, this function will be called for each decoration that gets dropped as a result of the mapping, passing the spec of that decoration.": {
    "_translate": "当设置该函数的时候，该函数会对在 mapping 过程中被移除的 decoration 调用该函数，传递 decoration 的配置对象。",
    "_note": ""
  },
  "Add the given array of decorations to the ones in the set, producing a new set. Consumes the decorations array. Needs access to the current document to create the appropriate tree structure.": {
    "_translate": "将给定的装饰数组添加到集合中的装饰中，生成一个新的集合。消耗<code>decorations</code>数组。需要访问当前文档以创建适当的树结构。",
    "_note": ""
  },
  "Create a new set that contains the decorations in this set, minus the ones in the given array.": {
    "_translate": "用当前的 decorations 集合减去给定数组中的 decorations，得到一个新的 decorations 集合。",
    "_note": ""
  },
  "Create a set of decorations, using the structure of the given document. This will consume (modify) the decorations array, so you must make a copy if you want need to preserve that.": {
    "_translate": "创建一组装饰，使用给定文档的结构。这将消耗（修改）<code>decorations</code>数组，因此如果需要保留它，必须制作一个副本。",
    "_note": ""
  },
  "The empty set of decorations.": {
    "_translate": "decorations 的空集合。",
    "_note": ""
  },
  "An object that can provide decorations. Implemented by DecorationSet, and passed to node views.": {
    "_translate": "一个可以提供 <a href=\"#view.EditorProps.decorations\">decorations</a> 的对象。被 <a href=\"#view.DecorationSet\"><code>DecorationSet</code></a> 实现，会被传给 <a href=\"#view.EditorProps.nodeViews\">node views</a> 方法。",
    "_note": ""
  },
  "Extract a DecorationSource containing decorations for the given child node at the given offset.": {
    "_translate": "提取一个DecorationSource，其中包含给定偏移量处给定子节点的装饰。",
    "_note": ""
  },
  "Call the given function for each decoration set in the group.": {
    "_translate": "为组中的每个装饰集调用给定函数。",
    "_note": ""
  },
  "This module defines ProseMirror's content model, the data structures used to represent and work with documents.": {
    "_translate": "这个模块定义了 ProseMirror 的内容模型，它的数据结构被用来表示文档和其内的节点并让它们按预期工作。",
    "_note": ""
  },
  "A ProseMirror document is a tree. At each level, a node describes the type of the content, and holds a fragment containing its children.": {
    "_translate": "一个 ProseMirror 的文档是一个树状结构。在每个层级中，一个 <a href=\"#model.Node\">node</a> 描述了内容的类型，同时通过 <a href=\"#model.Fragment\">fragment</a> 来保持对其子节点的引用。",
    "_note": ""
  },
  "This class represents a node in the tree that makes up a ProseMirror document. So a document is an instance of Node, with children that are also instances of Node.": {
    "_translate": "这个类表示 ProseMirror 中组成文档树的节点，因此一个文档就是一个 <code>Node</code> 的实例，以及它的子节点同样是 <code>Node</code> 的实例。",
    "_note": ""
  },
  "Nodes are persistent data structures. Instead of changing them, you create new ones with the content you want. Old ones keep pointing at the old document shape. This is made cheaper by sharing structure between the old and new data as much as possible, which a tree shape like this (without back pointers) makes easy.": {
    "_translate": "节点都是一些持久化的数据结构。每次更新会创建一个新的节点与一些你想要的内容，而不是改变旧的节点。旧的节点始终保持旧文档的引用。 这使得在旧的和新的数据之间共享结构变得容易，因为像这样的树状结构没有「向后的指针」（？）",
    "_note": ""
  },
  "Do not directly mutate the properties of a Node object. See the guide for more information.": {
    "_translate": "<strong>不要</strong> 直接修改 <code>Node</code> 对象的属性。查看 <a href=\"https://xheldon.com/prosemirror-guide-chinese.html#documents\">中文指南</a>获取更多信息。",
    "_note": ""
  },
  "The type of node that this is.": {
    "_translate": "当前节点的类型。",
    "_note": ""
  },
  "An object mapping attribute names to values. The kind of attributes allowed and required are determined by the node type.": {
    "_translate": "一个键值对。允许的和需要的 attributes <a href=\"#model.NodeSpec.attrs\">取决于</a> 节点类型。",
    "_note": ""
  },
  "The marks (things like whether it is emphasized or part of a link) applied to this node.": {
    "_translate": "应用到当前节点的 marks（marks 是一些类似于加粗或者链接一样的节点）",
    "_note": ""
  },
  "A container holding the node's children.": {
    "_translate": "一个持有节点子元素的容器。",
    "_note": "该容器是 Fragment 类型"
  },
  "For text nodes, this contains the node's text content.": {
    "_translate": "对于文本节点，它包含了节点的文本内容。",
    "_note": ""
  },
  "The size of this node, as defined by the integer-based indexing scheme. For text nodes, this is the amount of characters. For other leaf nodes, it is one. For non-leaf nodes, it is the size of the content plus two (the start and end token).": {
    "_translate": "表示该节点的大小，由基于整数的 <a href=\"https://xheldon.com/prosemirror-guide-chinese.html#indexing\">indexing scheme</a> 决定。 对于文本节点，它是字符数，对于其他叶子节点，是 1。对于非叶子节点，它是其内容的大小加上 2（开始和结束标签）。",
    "_note": "indexing scheme 链接指向中文翻译指南，请搜索 Document 一节 下的 Indexing 一节。"
  },
  "The number of children that the node has.": {
    "_translate": "该节点拥有的子节点个数。",
    "_note": ""
  },
  "Get the child node at the given index. Raises an error when the index is out of range.": {
    "_translate": "获取给定 index 处的子节点。如果 index 超出范围，则返回错误。",
    "_note": ""
  },
  "Get the child node at the given index, if it exists.": {
    "_translate": "获取给定 index 的子节点，如果存在的话。",
    "_note": "不存在返回 undefined。"
  },
  "Call f for every child node, passing the node, its offset into this parent node, and its index.": {
    "_translate": "为每一个子节点调用 <code>f</code> 函数，参数是子节点、子节点相对于当前节点的偏移、以及子节点的 index。",
    "_note": ""
  },
  "Call the given callback for every descendant node. Doesn't descend into a node when the callback returns false.": {
    "_translate": "对每一个后代节点调用给定的回调函数 <code>f</code>。当回调处理一个节点的时候返回 false ，则后续不会继续对该节点的子节点再调用该回调了。",
    "_note": "上述递归都是深度优先。"
  },
  "Invoke a callback for all descendant nodes recursively between the given two positions that are relative to start of this node's content. The callback is invoked with the node, its position relative to the original node (method receiver), its parent node, and its child index. When the callback returns false for a given node, that node's children will not be recursed over. The last parameter can be used to specify a starting position to count from.": {
    "_translate": "在给定的两个相对于此节点内容起始位置之间递归地为所有后代节点调用回调函数。回调函数以节点、其相对于原始节点（方法接收者）的位置、其父节点及其子索引为参数。当回调函数对某个节点返回false时，该节点的子节点将不会被递归。最后一个参数可用于指定一个起始位置进行计数。",
    "_note": ""
  },
  "Concatenates all the text nodes found in this fragment and its children.": {
    "_translate": "该节点的所有文本内容连接为一个字符串返回。",
    "_note": ""
  },
  "Get all text between positions from and to. When blockSeparator is given, it will be inserted to separate text from different block nodes. If leafText is given, it'll be inserted for every non-text leaf node encountered, otherwise leafText will be used.": {
    "_translate": "获取位置<code>from</code>和<code>to</code>之间的所有文本。当提供<code>blockSeparator</code>时，它将被插入以分隔来自不同块节点的文本。如果提供了<code>leafText</code>，它将被插入到遇到的每个非文本叶节点中，否则将使用<a href=\"#model.NodeSpec%5EleafText\"><code>leafText</code></a>。",
    "_note": ""
  },
  "Returns this node's first child, or null if there are no children.": {
    "_translate": "返回节点的第一个子节点，如果没有则是 <code>null</code>。",
    "_note": ""
  },
  "Returns this node's last child, or null if there are no children.": {
    "_translate": "返回节点的最后一个子节点，如果没有则是 <code>null</code>。",
    "_note": ""
  },
  "Test whether two nodes represent the same piece of document.": {
    "_translate": "测试两个节点是否表示的是文档中相同的部分。",
    "_note": "比较的手段是先比较节点的引用，如果相等直接为 true；否则比较 markup 是否相等，如果不是则返回 false，如果是再递归比较二者的子节点。"
  },
  "Compare the markup (type, attributes, and marks) of this node to those of another. Returns true if both have the same markup.": {
    "_translate": "比较当前与给定节点的 markup（包含类型、attributes 和 marks）是否相等。如果相同返回 <code>true</code>。",
    "_note": ""
  },
  "Check whether this node's markup correspond to the given type, attributes, and marks.": {
    "_translate": "检查节点是否有给定的类型、attributes 和 marks。",
    "_note": ""
  },
  "Create a new node with the same markup as this node, containing the given content (or empty, if no content is given).": {
    "_translate": "新建一个与当前节点有相同 markup 的节点，包含给定的内容（如果没有给定内容则为空）。",
    "_note": ""
  },
  "Create a copy of this node, with the given set of marks instead of the node's own marks.": {
    "_translate": "新建一个当前节点的副本，包含给定的 marks，而不是当前节点原始的 marks。",
    "_note": ""
  },
  "Create a copy of this node with only the content between the given positions. If to is not given, it defaults to the end of the node.": {
    "_translate": "创建一个当前节点的副本，该节点仅包含给定位置范围的内容。如果 <code>to</code> 没有给定，则默认是当前节点的结束位置。",
    "_note": ""
  },
  "Cut out the part of the document between the given positions, and return it as a Slice object.": {
    "_translate": "剪切文档给定位置范围的部分，然后作为 <code>Slice</code> 对象返回。",
    "_note": ""
  },
  "Replace the part of the document between the given positions with the given slice. The slice must 'fit', meaning its open sides must be able to connect to the surrounding content, and its content nodes must be valid children for the node they are placed into. If any of this is violated, an error of type ReplaceError is thrown.": {
    "_translate": "用给定的 slice 替换给定位置范围的文档内容。slice 必须「适合」该位置范围，也就是说，slice 打开的两侧必须能够正确的连接它两侧被切开的周围的内容， 同时它的子节点也必须符合放入位置的祖先节点的 scheme 约束。如果有任何违背，那么将会抛出一个 <a href=\"#model.ReplaceError\"><code>ReplaceError</code></a>。",
    "_note": ""
  },
  "Find the node directly after the given position.": {
    "_translate": "返回给定位置右侧的节点。",
    "_note": ""
  },
  "Find the (direct) child node after the given offset, if any, and return it along with its index and offset relative to this node.": {
    "_translate": "如果有的话，返回给定偏移量后面的直接子节点，同时返回它的 index 以及相对于当前节点的偏移。",
    "_note": ""
  },
  "Find the (direct) child node before the given offset, if any, and return it along with its index and offset relative to this node.": {
    "_translate": "如果有的话，返回给定偏移量前面的直接子节点，同时返回它的 index 以及相对于当前节点的偏移。",
    "_note": ""
  },
  "Test whether a given mark or mark type occurs in this document between the two given positions.": {
    "_translate": "测试文档中给定的位置范围内是否有给定的 mark 或者 mark 类型。",
    "_note": ""
  },
  "Resolve the given position in the document, returning an object with information about its context.": {
    "_translate": "resolve 文档中给定的位置，返回一个关于此位置上下文信息的 <a href=\"#model.ResolvedPos\">object</a>。",
    "_note": ""
  },
  "True when this is a block (non-inline node)": {
    "_translate": "是否是一个块级节点（非内联节点的都是块级节点）。",
    "_note": ""
  },
  "True when this is a textblock node, a block node with inline content.": {
    "_translate": "是否是一个文本块节点（textblock），即有内联内容的块级节点。",
    "_note": ""
  },
  "True when this node allows inline content.": {
    "_translate": "节点是否允许内联内容。",
    "_note": ""
  },
  "True when this is an inline node (a text node or a node that can appear among text).": {
    "_translate": "节点是否是内联节点（文本节点或者能够出现在文本之间的节点都是内联节点）。",
    "_note": ""
  },
  "True when this is a text node.": {
    "_translate": "是否是文本节点。",
    "_note": ""
  },
  "True when this is a leaf node.": {
    "_translate": "是否是一个叶子节点。",
    "_note": ""
  },
  "True when this is an atom, i.e. when it does not have directly editable content. This is usually the same as isLeaf, but can be configured with the atom property on a node's spec (typically used when the node is displayed as an uneditable node view).": {
    "_translate": "是否是一个原子节点，例如，它没有一个直接可编辑的内容。它的值通常与 <code>isLeaf</code> 一样，不过可以通过节点配置对象上的 <a href=\"#model.NodeSpec.atom\"><code>atom</code> 属性</a> 进行设置。 （典型的使用场景是节点展示成一个不可编辑的 <a href=\"#view.NodeView\">node view</a>）。",
    "_note": ""
  },
  "Return a string representation of this node for debugging purposes.": {
    "_translate": "为了 debug 目的获取当前节点的字符串表示。",
    "_note": ""
  },
  "Get the content match in this node at the given index.": {
    "_translate": "获取当前节点给定 index 的 content match。",
    "_note": "content match 在 ProseMirror 中也是一个专有名词。"
  },
  "Test whether replacing the range between from and to (by child index) with the given replacement fragment (which defaults to the empty fragment) would leave the node's content valid. You can optionally pass start and end indices into the replacement fragment.": {
    "_translate": "测试用给定的 fragment（默认是空的 fragment） 替换 <code>from</code> 到 <code>to</code>（from 和 to 是子节点位置 index） 之间的内容是否合法（即符合 schema 约束）。 你可以可选的传入 <code>start</code> 和 <code>end</code>（start 和 end 都是子节点的位置 index）以只用 fragment 的一部分替换。",
    "_note": ""
  },
  "Test whether replacing the range from to to (by index) with a node of the given type would leave the node's content valid.": {
    "_translate": "测试用给定的节点类型替换当前节点 <code>from</code> 到 <code>to</code> index 之间的子元素是否合法。",
    "_note": ""
  },
  "Test whether the given node's content could be appended to this node. If that node is empty, this will only return true if there is at least one node type that can appear in both nodes (to avoid merging completely incompatible nodes).": {
    "_translate": "测试给定节点的内容可以被附加到当前节点最后。如果给定节点是空的，那么只有当至少一个节点类型能够出现在这两个节点之内的时候才会返回 true（以避免合并完全不兼容的节点）。",
    "_note": ""
  },
  "Check whether this node and its descendants conform to the schema, and raise an exception when they do not.": {
    "_translate": "检查此节点及其后代是否符合 scheme 约束，如果不符合则引发异常。",
    "_note": ""
  },
  "Return a JSON-serializeable representation of this node.": {
    "_translate": "返回一个当前节点 JSON 序列化的表示。",
    "_note": "不像我们认为的 JSON 序列化后与 stringify 过一样是个字符串，这里的序列化后是个对象。"
  },
  "Deserialize a node from its JSON representation.": {
    "_translate": "从一个节点 JSON 序列化的对象中反序列化出 Node 节点。",
    "_note": ""
  },
  "A fragment represents a node's collection of child nodes.": {
    "_translate": "一个 fragment 表示了节点的子节点集合。",
    "_note": ""
  },
  "Like nodes, fragments are persistent data structures, and you should not mutate them or their content. Rather, you create new instances whenever needed. The API tries to make this easy.": {
    "_translate": "像 nodes 一样，fragment 也是一个持久化数据结构，你不应该直接修改他们或者他们的内容，而应该创建一个新的实例。下面的 API 就是用来试图将这件事变得容易。",
    "_note": ""
  },
  "The size of the fragment, which is the total of the size of its content nodes.": {
    "_translate": "fragment 的大小，也即它的内容节点大小的总和。",
    "_note": ""
  },
  "Invoke a callback for all descendant nodes between the given two positions (relative to start of this fragment). Doesn't descend into a node when the callback returns false.": {
    "_translate": "对相对于 fragment 开始位置的两个位置范围内的节点调用 <code>f</code> 回调。如果某个节点的回调返回 <code>false</code>，则不会对该节点的内部节点再调用该回调了。",
    "_note": ""
  },
  "Call the given callback for every descendant node. pos will be relative to the start of the fragment. The callback may return false to prevent traversal of a given node's children.": {
    "_translate": "为每个子节点调用给定的回调函数。<code>pos</code>将相对于片段的起始位置。回调函数可以返回<code>false</code>以阻止遍历给定节点的子节点。",
    "_note": ""
  },
  "Extract the text between from and to. See the same method on Node.": {
    "_translate": "提取<code>from</code>和<code>to</code>之间的文本。请参阅<a href=\"#model.Node.textBetween\"><code>Node</code></a>上的相同方法。",
    "_note": ""
  },
  "Create a new fragment containing the combined content of this fragment and the other.": {
    "_translate": "创建一个包含当前 fragment 内容和给定 fragment 内容的新的 fragment。",
    "_note": ""
  },
  "Cut out the sub-fragment between the two given positions.": {
    "_translate": "从 fragment 剪切出给定范围的一个子 fragment。",
    "_note": ""
  },
  "Create a new fragment in which the node at the given index is replaced by the given node.": {
    "_translate": "将 fragment 中的给定 index 位置的节点用给定节点替换掉后，创建一个新的 fragment。",
    "_note": ""
  },
  "Create a new fragment by prepending the given node to this fragment.": {
    "_translate": "将给定节点添加到此片段的前面以创建一个新的片段。",
    "_note": ""
  },
  "Create a new fragment by appending the given node to this fragment.": {
    "_translate": "通过将给定节点附加到此片段来创建一个新片段。",
    "_note": ""
  },
  "Compare this fragment to another one.": {
    "_translate": "将当前 fragment 与另一个 fragment 比较，看是否相等。。",
    "_note": "先比较 fragment 的内容大小，再逐个对内容节点调用节点的 eq 方法进行比较，一旦发现不一样的则返回 false，否则返回 true。"
  },
  "The first child of the fragment, or null if it is empty.": {
    "_translate": "返回当前 fragment 的第一个子节点，如果是空则为 <code>null</code>。",
    "_note": ""
  },
  "The last child of the fragment, or null if it is empty.": {
    "_translate": "返回当前 fragment 的最后一个节点，如果是空则为 <code>null</code>。",
    "_note": ""
  },
  "The number of child nodes in this fragment.": {
    "_translate": "当前 fragment 的子节点数量。",
    "_note": ""
  },
  "Get the child node at the given index. Raise an error when the index is out of range.": {
    "_translate": "获取 fragment 在给定 index 的子节点。如果 index 超出范围则抛出一个错误。",
    "_note": ""
  },
  "Find the first position at which this fragment and another fragment differ, or null if they are the same.": {
    "_translate": "寻找当前 fragment 和给定 fragment 的第一个不同的位置，如果它们相同的话返回 <code>null</code>。",
    "_note": ""
  },
  "Find the first position, searching from the end, at which this fragment and the given fragment differ, or null if they are the same. Since this position will not be the same in both nodes, an object with two separate positions is returned.": {
    "_translate": "从后往前搜索，寻找当前 fragment 和给定 fragment 的第一个不同的位置，如果相同则返回 <code>null</code>。 因为该位置在两个节点中可能是不同的，因此该函数返回的是一个对象，带有两个不同的位置。",
    "_note": "对象是 {a: number, b: number}。"
  },
  "Return a debugging string that describes this fragment.": {
    "_translate": "返回一个用来 debug 的 string 以描述该 fragment。",
    "_note": ""
  },
  "Create a JSON-serializeable representation of this fragment.": {
    "_translate": "返回该 fragment 序列化后的 JSON 表示。",
    "_note": ""
  },
  "Deserialize a fragment from its JSON representation.": {
    "_translate": "从其JSON表示中反序列化片段。",
    "_note": ""
  },
  "Build a fragment from an array of nodes. Ensures that adjacent text nodes with the same marks are joined together.": {
    "_translate": "用一个节点数组构建一个 fragment。带有相同 marks 的相邻文本节点会被合并到一起。",
    "_note": ""
  },
  "Create a fragment from something that can be interpreted as a set of nodes. For null, it returns the empty fragment. For a fragment, the fragment itself. For a node or array of nodes, a fragment containing those nodes.": {
    "_translate": "用给定的类节点集合的对象中创建一个 fragment。如果是 <code>null</code> 则返回空 fragment。 如果是 fragment 则返回该 fragment 自身。如果是一个节点或者一个节点数组，则返回一个包含这些节点的 fragment。",
    "_note": ""
  },
  "An empty fragment. Intended to be reused whenever a node doesn't contain anything (rather than allocating a new empty fragment for each leaf node).": {
    "_translate": "一个空的 fragment。没有包含任何节点的 fragment 都指向该对象（而不是为每个 fragment 都创建一个空的 fragment）。",
    "_note": ""
  },
  "A mark is a piece of information that can be attached to a node, such as it being emphasized, in code font, or a link. It has a type and optionally a set of attributes that provide further information (such as the target of the link). Marks are created through a Schema, which controls which types exist and which attributes they have.": {
    "_translate": "Mark 是可以被附加到节点上的一小段信息，比如加粗行内代码或者加粗链接字体。它有一个可选的 attributes 集合以提供更多信息 （比如链接的 target 信息等）。Marks 通过 <code>Schema</code> 创建，它控制哪些 marks 存在于哪些节点以及拥有哪些 attributes。",
    "_note": ""
  },
  "The type of this mark.": {
    "_translate": "当前 mark 的 type。",
    "_note": ""
  },
  "The attributes associated with this mark.": {
    "_translate": "与此 mark 相关的 attributes。",
    "_note": ""
  },
  "Given a set of marks, create a new set which contains this one as well, in the right position. If this mark is already in the set, the set itself is returned. If any marks that are set to be exclusive with this mark are present, those are replaced by this one.": {
    "_translate": "将当前 marks 加入到给定 marks 集合的右侧（后面）后返回新的 marks 集合。如果当前 marks 已经存在于给定集合当中 那么给定集合自身会被返回。如果给定集合中有任何 marsk 配置对象的 <a href=\"#model.MarkSpec.excludes\">exclusive</a> 属性值中有当前 mark，那么它会被用当前 mark 替换掉。",
    "_note": ""
  },
  "Test whether this mark is in the given set of marks.": {
    "_translate": "测试是否当前 mark 在给定 marks 集合中。",
    "_note": ""
  },
  "Remove this mark from the given set, returning a new set. If this mark is not in the set, the set itself is returned.": {
    "_translate": "从给定的 marks 集合中移除当前 mark。如果当前 mark 不在集合中，那么给定集合本身会被返回。",
    "_note": ""
  },
  "Test whether this mark has the same type and attributes as another mark.": {
    "_translate": "测试当前 mark 与给定 mark 是否有相同的类型和 attributes。",
    "_note": ""
  },
  "Convert this mark to a JSON-serializeable representation.": {
    "_translate": "返回当前 mark 的 JSON 序列化的表示。",
    "_note": ""
  },
  "Deserialize a mark from JSON.": {
    "_translate": "从 JSON 反序列化标记。",
    "_note": ""
  },
  "Test whether two sets of marks are identical.": {
    "_translate": "测试两个 marks 集合是否一样。",
    "_note": "marks 集合是否相同的比较是是先测试 marks 集合中的 mark 数量，然后逐个调用 mark 的 eq 进行比较。"
  },
  "Create a properly sorted mark set from null, a single mark, or an unsorted array of marks.": {
    "_translate": "用给定的参数，新建一个 stored marks 集合，该参数可能是 null、单独一个 mark或者一个未排序的 marks 数组。",
    "_note": ""
  },
  "The empty set of marks.": {
    "_translate": "marks 的空集合。",
    "_note": ""
  },
  "A slice represents a piece cut out of a larger document. It stores not only a fragment, but also the depth up to which nodes on both side are ‘open’ (cut through).": {
    "_translate": "一个 slice 表示从大的文档中切出去的一小段片段。它不仅存储着 fragment，还有它两侧的节点「开放」的深度（切割节点产生的）。",
    "_note": ""
  },
  "It is not necessary for the content of open nodes to conform to the schema's content constraints, though it should be a valid start/end/middle for such a node, depending on which sides are open.": {
    "_translate": "开放节点的内容无需一定要符合 schema 的内容限制，因为对于开放节点来说，它的内容应该被在一个有效的开始/结束/中间位置开放，而这具体取决于节点的哪一侧被打开。",
    "_note": "这句话举个例子比较好理解，如果 schema 内容限制 li 不能包含 p，但如果一个 slice 的 fragment 结构是 &lt;li&gt;&lt;p&gt;123&lt;/p&gt;&lt;p&gt;456&lt;/p&gt;&lt;/li&gt;，openStart 是 2，openEnd 也是 2 那么该 slice 切割（打开/开放）出来的节点就会形如 123&lt;p&gt;456, 因此也是一个有效的 slice，可以被放到文档中需要的地方去（如另个一 p 标签内）。"
  },
  "Create a slice. When specifying a non-zero open depth, you must make sure that there are nodes of at least that depth at the appropriate side of the fragment—i.e. if the fragment is an empty paragraph node, openStart and openEnd can't be greater than 1.": {
    "_translate": "新建一个 slice。当指定一个非零的开放深度的时候，你必须保证该 slice 的 fragment 至少在这个深度存在节点。 例如，如果节点是一个空的段落节点，那么 <code>openStart</code> 和 <code>openEnd</code> 不能大于 1。",
    "_note": ""
  },
  "The slice's content.": {
    "_translate": "该 slice 的内容片段。",
    "_note": "该内容片段以 Fragment 的实例形式存在。"
  },
  "The open depth at the start of the fragment.": {
    "_translate": "片段开始时的开放深度。",
    "_note": ""
  },
  "The open depth at the end.": {
    "_translate": "结束位置的开放深度。",
    "_note": ""
  },
  "The size this slice would add when inserted into a document.": {
    "_translate": "当将插入 slice 到文档中时，插入的内容大小。",
    "_note": ""
  },
  "Tests whether this slice is equal to another slice.": {
    "_translate": "测试当前 slice 是否与另一个 slice 相等。",
    "_note": "相等比较是比较 slice 的内容，也即调用 fragment 的 eq 方法比较的，而且需要满足 openStart 相等和 openEnd 相等。"
  },
  "Convert a slice to a JSON-serializable representation.": {
    "_translate": "返回当前 slice 的 JSON 序列化的表示。",
    "_note": ""
  },
  "Deserialize a slice from its JSON representation.": {
    "_translate": "从 slice 的 JSON 表示形式反序列化出一个 slice。",
    "_note": ""
  },
  "Create a slice from a fragment by taking the maximum possible open value on both side of the fragment.": {
    "_translate": "从一个 fragment 新建一个 slice，该 slice 两侧的的打开值尽可能的大。",
    "_note": ""
  },
  "The empty slice.": {
    "_translate": "空的 Slice。",
    "_note": ""
  },
  "An object holding the attributes of a node.": {
    "_translate": "一个包含节点属性的对象。",
    "_note": ""
  },
  "Error type raised by Node.replace when given an invalid replacement.": {
    "_translate": "一种调用 <a href=\"#model.Node.replace\"><code>Node.replace</code></a> 方法时如果给定替换内容不可用的话会返回的错误类型。",
    "_note": ""
  },
  "Positions in a document can be represented as integer offsets. But you'll often want to use a more convenient representation.": {
    "_translate": "在文档中的位置可以表示为一个整数的 <a href=\"https://xheldon.com/prosemirror-guide-chinese.html#indexing\">offsets</a>。不过你经常会想要使用一种更方便表达形式来使用位置信息。",
    "_note": ""
  },
  "Throughout this interface, methods that take an optional depth parameter will interpret undefined as this.depth and negative numbers as this.depth + value.": {
    "_translate": "通过这个接口，对于那些接受可选参数 <code>depth</code> 的方法来说，如果没有传入该参数则默认会是 <code>this.depth</code>，如果是负数则会是 <code>this.depth + value</code>。",
    "_note": ""
  },
  "You can resolve a position to get more information about it. Objects of this class represent such a resolved position, providing various pieces of context information, and some helper methods.": {
    "_translate": "你可以 <a href=\"#model.Node.resolve\"><em>resolve</em></a> 一个位置以得到该位置的更多信息。该类的对象就是表示这样一种 resolve 过的位置， 它提供一些上下文信息，以及一些有用的工具函数。",
    "_note": ""
  },
  "The number of levels the parent node is from the root. If this position points directly into the root node, it is 0. If it points into a top-level paragraph, 1, and so on.": {
    "_translate": "从根节点开始算，它的父节点的深度。如果位置直接指向根节点，则是 0。如果它指向一个顶级节点如段落，则是 1，以此类推。",
    "_note": ""
  },
  "The position that was resolved.": {
    "_translate": "被 resolve 的位置。",
    "_note": ""
  },
  "The offset this position has into its parent node.": {
    "_translate": "该位置相对于父节点的偏移量。",
    "_note": ""
  },
  "The parent node that the position points into. Note that even if a position points into a text node, that node is not considered the parent—text nodes are ‘flat’ in this model, and have no content.": {
    "_translate": "该位置指向的父级节点。记住，即使一个位置指向的是文本节点，那该节点也不认为是父级，因为文本节点在 ProseMirror 世界里是 「扁平」的，它没有内容。",
    "_note": ""
  },
  "The root node in which the position was resolved.": {
    "_translate": "该位置被 resolve 的根节点。",
    "_note": ""
  },
  "The ancestor node at the given level. p.node(p.depth) is the same as p.parent.": {
    "_translate": "在给定深度的祖先节点。p.node(p.depth)<code>与</code>p.parent` 相同。",
    "_note": ""
  },
  "The index into the ancestor at the given level. If this points at the 3rd node in the 2nd paragraph on the top level, for example, p.index(0) is 1 and p.index(1) is 2.": {
    "_translate": "在给定深度的祖先节点的 index。例如，如果该位置指向顶级节点的第二个段落的第三个节点，那么 <code>p.index(0)</code> 是 1，<code>p.index(1)</code> 是 2。",
    "_note": ""
  },
  "The index pointing after this position into the ancestor at the given level.": {
    "_translate": "在给定深度的祖先节点后面节点的 index。",
    "_note": ""
  },
  "The (absolute) position at the start of the node at the given level.": {
    "_translate": "给定深度的祖先节点的开始位置（绝对位置）。",
    "_note": "绝对位置是相对于 doc 根节点的位置，一般都是用它来定位。"
  },
  "The (absolute) position at the end of the node at the given level.": {
    "_translate": "给定深度的祖先节点的结束位置（绝对位置）。",
    "_note": ""
  },
  "The (absolute) position directly before the wrapping node at the given level, or, when depth is this.depth + 1, the original position.": {
    "_translate": "在给定深度的祖先节点之前的（绝对）位置，或者，如果 <code>depth</code> 是 <code>this.depth + 1</code> 的话，则是原始的位置。",
    "_note": ""
  },
  "The (absolute) position directly after the wrapping node at the given level, or the original position when depth is this.depth + 1.": {
    "_translate": "在给定深度的祖先节点之后的（绝对）位置，或者如果 <code>depth</code> 是 <code>this.depth + 1</code> 的话则是原始的位置。",
    "_note": "「before 之前」、「start 开始」、「after 之后」、「end 结束」位置的区别：有以下结构 &lt;p&gt;123&lt;/p&gt;，若用 I表示「这个」位置，则： I&lt;p&gt;123&lt;/p&gt; 表示 before；&lt;p&gt;I123&lt;/p&gt; 表示 start；&lt;p&gt;123I&lt;/p&gt; 表示 end；&lt;p&gt;123&lt;/p&gt;I 表示 after。"
  },
  "When this position points into a text node, this returns the distance between the position and the start of the text node. Will be zero for positions that point between nodes.": {
    "_translate": "当位置指向一个文本节点，该函数返回当前位置到文本节点开始位置的距离。如果指向节点之间则是 0。",
    "_note": ""
  },
  "Get the node directly after the position, if any. If the position points into a text node, only the part of that node after the position is returned.": {
    "_translate": "获取紧挨着该位置后的节点，如果有的话。如果位置指向一个文本节点，则只有在文本节点中该位置之后的内容会被返回。",
    "_note": ""
  },
  "Get the position at the given index in the parent node at the given depth (which defaults to this.depth).": {
    "_translate": "获取在给定深度的祖先节点的给定 index 的位置（深度默认是 <code>this.depth</code>)。",
    "_note": ""
  },
  "Get the node directly before the position, if any. If the position points into a text node, only the part of that node before the position is returned.": {
    "_translate": "获取紧挨着该位置前的节点，如果有的话。如果位置指向一个文本节点，则只有在文本节点中该位置之前的内容会被返回。",
    "_note": ""
  },
  "Get the marks at this position, factoring in the surrounding marks' inclusive property. If the position is at the start of a non-empty node, the marks of the node after it (if any) are returned.": {
    "_translate": "充分考虑 marks 们的 <a href=\"#model.MarkSpec.inclusive\"><code>inclusive</code></a> 属性后，获取当前位置的最终的 marks。如果该位置是在一个非空节点的起始位置，则会返回该位置之后节点的 marks（如果有的话）。",
    "_note": "如果位置在一个空元素内，则返回空的数组（即 Mark 的静态属性，Mark.none)。如果是在一个文本节点中，则简单返回文本节点的 marks。 如果在一个非空节点的起始位置（before 为空），则考虑该位置之后节点的 marks。最后（此时只剩一种情况，也即在一个非文本节点的末尾位置）考虑排除那些设置了 inclusive 属性为 false 的 marks 们。"
  },
  "Get the marks after the current position, if any, except those that are non-inclusive and not present at position $end. This is mostly useful for getting the set of marks to preserve after a deletion. Will return null if this position is at the end of its parent node or its parent node isn't a textblock (in which case no marks should be preserved).": {
    "_translate": "获取在当前位置之后的 marks，如果有的话，会排除那些 inclusive 为 false 以及没有出现在 <code>$end</code> 位置的 marks 们。 这个方法最有用的场景是在执行删除操作后获取需要保留的 marks 集合。如果该位置在它的父级节点的结束的地方或者它的父级节点不是一个文本 block，则会返回 null（此时不应该有任何 marks 被保留）。",
    "_note": ""
  },
  "The depth up to which this position and the given (non-resolved) position share the same parent nodes.": {
    "_translate": "返回在给定位置和当前位置拥有的相同父级节点所在的最大深度。",
    "_note": ""
  },
  "Returns a range based on the place where this position and the given position diverge around block content. If both point into the same textblock, for example, a range around that textblock will be returned. If they point into different blocks, the range around those blocks in their shared ancestor is returned. You can pass in an optional predicate that will be called with a parent node to see if a range into that parent is acceptable.": {
    "_translate": "根据当前位置与给定位置围绕块级节点的周围看返回相应的 Range。例如，如果两个位置都指向一个文本 block，则文本 block 的 range 会被返回； 如果它们指向不同的块级节点，则包含这些块级节点的深度最大的共同祖先节点 range 将会被返回。你可以传递一个指示函数，来决定该祖先节点是否可接受。",
    "_note": ""
  },
  "Query whether the given position shares the same parent node.": {
    "_translate": "当前位置和给定位置是否具有相同的父级节点。",
    "_note": ""
  },
  "Return the greater of this and the given position.": {
    "_translate": "返回当前位置和给定位置较大的那个。",
    "_note": ""
  },
  "Return the smaller of this and the given position.": {
    "_translate": "返回当前位置和给定位置较小的那个。",
    "_note": ""
  },
  "Represents a flat range of content, i.e. one that starts and ends in the same node.": {
    "_translate": "表示一个内容的扁平范围（range），例如，一个开始和结束在相同节点的范围。",
    "_note": ""
  },
  "Construct a node range. $from and $to should point into the same node until at least the given depth, since a node range denotes an adjacent set of nodes in a single parent node.": {
    "_translate": "构造一个节点 range。至少深度在 <code>depth</code> 及更小的时候 <code>$from</code> 和 <code>$to</code> 应该始终指向相同的节点，因为一个节点 range 表示具有相同父级节点的相邻节点的集合。",
    "_note": ""
  },
  "A resolved position along the start of the content. May have a depth greater than this object's depth property, since these are the positions that were used to compute the range, not re-resolved positions directly at its boundaries.": {
    "_translate": "range 的内容开始处 resolve 过的位置。它可能有一个大于该 range 的 <code>depth</code> 属性的深度，因为这些位置是用来计算 range 的，其不会直接在 range 的边界再次 resolve。",
    "_note": ""
  },
  "A position along the end of the content. See caveat for $from.": {
    "_translate": "range 的内容结束处 resolve 过的位置。看一下关于 <a href=\"#model.NodeRange.$from\"><code>$from</code></a> 的警告。",
    "_note": "举个例子：有以下结构 &lt;ul&gt;&lt;li&gt;&lt;p&gt;abc&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;123&lt;/p&gt;&lt;p&gt;456&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt; 则构造一个 NodeRange 的时候，如果 $from 在 1 后面位置，$to 在 4 后面位置，则 depth 必须是在第二个 li 的开始位置的深度或者更小，因为如果再深的话，$from 和 $to 就没有共同的父级节点，就无法构建一个 NodeRange。也因此，$from 和 $to 的 depth 属性是有可能大于 NodeRange 的 depth 属性的。"
  },
  "The depth of the node that this range points into.": {
    "_translate": "该 range 指向的节点的深度。",
    "_note": ""
  },
  "The position at the start of the range.": {
    "_translate": "该 range 开始的位置。",
    "_note": ""
  },
  "The position at the end of the range.": {
    "_translate": "该 range 结束的位置。",
    "_note": ""
  },
  "The parent node that the range points into.": {
    "_translate": "该 range 所在的父级节点。",
    "_note": ""
  },
  "The start index of the range in the parent node.": {
    "_translate": "该 range 在父级节点中的开始处的 index。",
    "_note": ""
  },
  "The end index of the range in the parent node.": {
    "_translate": "该 range 在父级节点中结束处的 index。",
    "_note": ""
  },
  "Every ProseMirror document conforms to a schema, which describes the set of nodes and marks that it is made out of, along with the relations between those, such as which node may occur as a child node of which other nodes.": {
    "_translate": "每个 ProseMirror 文档都符合一个 <a href=\"https://xheldon.com/prosemirror-guide-chinese.html#schemas\">schema</a> 约束，它描述了节点的集合和 marks，以及它们之间的关系，比如哪些节点可以作为其他节点的子节点等。",
    "_note": ""
  },
  "A document schema. Holds node and mark type objects for the nodes and marks that may occur in conforming documents, and provides functionality for creating and deserializing such documents.": {
    "_translate": "一个文档的 schema。对可能出现在文档中的 nodes 和 marks 提供相应的 <a href=\"#model.NodeType\">node type</a> 和 <a href=\"#model.MarkType\">mark type</a> 对象， 以及提供相应创建和序列化这样一个文档的函数。",
    "_note": ""
  },
  "When given, the type parameters provide the names of the nodes and marks in this schema.": {
    "_translate": "当给定时，类型参数提供此架构中节点和标记的名称。",
    "_note": ""
  },
  "Construct a schema from a schema specification.": {
    "_translate": "构造一个 schema 从一个 schema <a href=\"#model.SchemaSpec\">specification（配置对象）</a>中。",
    "_note": ""
  },
  "The spec on which the schema is based, with the added guarantee that its nodes and marks properties are OrderedMap instances (not raw objects).": {
    "_translate": "当前 schema 所基于的 <a href=\"#model.SchemaSpec\">spec（配置对象）</a>，其中的 <code>nodes</code> 和 <code>marks</code> 属性可以保证是 <a href=\"https://github.com/marijnh/orderedmap\"><code>OrderedMap</code></a> 的实例（不是原始对象）。",
    "_note": ""
  },
  "An object mapping the schema's node names to node type objects.": {
    "_translate": "一个 schema 中节点名和节点类型对象的键值对映射。",
    "_note": ""
  },
  "A map from mark names to mark type objects.": {
    "_translate": "一个 mark 名和 mark 类型对象的键值对映射。",
    "_note": ""
  },
  "The linebreak replacement node defined in this schema, if any.": {
    "_translate": "<a href=\"#model.NodeSpec.linebreakReplacement\">换行符替换</a>节点在此模式中定义（如果有）。",
    "_note": ""
  },
  "The type of the default top node for this schema.": {
    "_translate": "当前 schema 的 <a href=\"#model.SchemaSpec.topNode\">默认顶级节点</a> 类型。",
    "_note": ""
  },
  "An object for storing whatever values modules may want to compute and cache per schema. (If you want to store something in it, try to use property names unlikely to clash.)": {
    "_translate": "一个用于计算和缓存每个 schema 中的任何类型值的对象。（如果你想要在其上储存一些东西，要保证属性名不会冲突）",
    "_note": ""
  },
  "Create a node in this schema. The type may be a string or a NodeType instance. Attributes will be extended with defaults, content may be a Fragment, null, a Node, or an array of nodes.": {
    "_translate": "在 schema 中新建一个节点。<code>type</code> 参数可以是一个字符串或者一个 <code>NodeType</code> 的实例。Attributes 会被以默认值扩展，<code>content</code> 可能是一个 <code>Fragment</code>、 <code>null</code>、<code>Node</code> 或者一个节点数组。",
    "_note": ""
  },
  "Create a text node in the schema. Empty text nodes are not allowed.": {
    "_translate": "在 schema 中新建一个文本节点。不允许创建空的文本节点。",
    "_note": "文本节点和文本块节点不同，注意区分。"
  },
  "Create a mark with the given type and attributes.": {
    "_translate": "用给定的类型和 attributes 创建一个 mark。",
    "_note": ""
  },
  "Deserialize a node from its JSON representation. This method is bound.": {
    "_translate": "从一个 JSON 表达式中反序列化出一个节点。该方法 this 已经绑定当前对象。",
    "_note": "JSON 表达式其实并不是 JavaScript 中通常意义上的 JSON 字符串，而是一个普通对象，它及它的键值都是 plain object。该对象由相应的 Node.toJSON 生成。"
  },
  "Deserialize a mark from its JSON representation. This method is bound.": {
    "_translate": "从一个 JSON 表达式中反序列化出一个 mark。该方法 this 已经绑定当前对象。",
    "_note": "该对象由相应的 Mark.toJSON 生成。"
  },
  "An object describing a schema, as passed to the Schema constructor.": {
    "_translate": "一个描述 schema 的对象，用来传递给 <a href=\"#model.Schema\"><code>Schema</code></a> 构造函数",
    "_note": "就是 schema 的配置对象，ProseMirror 中的 xxxSpec 都是 xxx 的配置对象，如 NodeSpec、MarkSpec 等。"
  },
  "The node types in this schema. Maps names to NodeSpec objects that describe the node type associated with that name. Their order is significant—it determines which parse rules take precedence by default, and which nodes come first in a given group.": {
    "_translate": "当前 schema 中所有的 node 类型的对象。对象中，键是节点名，对象的键是对应的 <a href=\"#model.NodeSpec\"><code>NodeSpec</code></a>。 节点们在该对象中出现的先后顺序是非常重要的，它决定了默认情况下哪个节点的 <a href=\"#model.NodeSpec.parseDOM\">parse rules</a> 优先进行， 以及哪个节点是一个 group 优先考虑的节点。",
    "_note": ""
  },
  "The mark types that exist in this schema. The order in which they are provided determines the order in which mark sets are sorted and in which parse rules are tried.": {
    "_translate": "当前 schema 中的所有 mark 类型的对象。它们出现的顺序决定了在 <a href=\"#model.Mark.addToSet\">mark sets</a> 中的存储顺序，以及 <a href=\"#model.MarkSpec.parseDOM\">parse rules</a> 的处理顺序。",
    "_note": ""
  },
  "The name of the default top-level node for the schema. Defaults to \"doc\".": {
    "_translate": "当前 schema 顶级节点的名字，默认是 <code>\"doc\"</code>。",
    "_note": ""
  },
  "A description of a node type, used when defining a schema.": {
    "_translate": "节点类型的描述，用于定义模式时。",
    "_note": ""
  },
  "The content expression for this node, as described in the schema guide. When not given, the node does not allow any content.": {
    "_translate": "就像在 <a href=\"https://xheldon.com/prosemirror-guide-chinese.html#content-expressions\">schema guide</a> 中描述的一样，为当前节点的内容表达式。 如果没有给定，则该节点不允许任何内容。",
    "_note": "schema guide 链接指向中文翻译指南，请搜索 Schema 下的 Content Expressions 一节。"
  },
  "The marks that are allowed inside of this node. May be a space-separated string referring to mark names or groups, \"_\" to explicitly allow all marks, or \"\" to disallow marks. When not given, nodes with inline content default to allowing all marks, other nodes default to not allowing marks.": {
    "_translate": "当前节点允许的 marks 类型。可能是一个空格分隔的字符串，内容是 mark 的名字或者 group 名。 <code>\"_\"</code> 表示明确允许所有的 marks，或者 <code>\"\"</code> 表示禁止所有的 marks。如果没有设置该字段，则节点含有的内联内容将会默认允许所有的 marks， 其他不含内联内容的节点将默认不允许所有的 marks。",
    "_note": ""
  },
  "The group or space-separated groups to which this node belongs, which can be referred to in the content expressions for the schema.": {
    "_translate": "当前节点所属的 group，可以出现多个，用空格分隔，可以指向当前 schema 的内容表达式（content expressions）。",
    "_note": ""
  },
  "Should be set to true for inline nodes. (Implied for text nodes.)": {
    "_translate": "对于内联节点，应该被设置为 true（文本节点隐式的被设置为 true）。",
    "_note": ""
  },
  "Can be set to true to indicate that, though this isn't a leaf node, it doesn't have directly editable content and should be treated as a single unit in the view.": {
    "_translate": "可以被设置为 true，以表示即使当前节点不是一个 <a href=\"#model.NodeType.isLeaf\">leaf node</a>，但是其也没有直接可编辑内容， 因此在 view 中应该被当成是一个独立的单位对待。",
    "_note": "「独立单位对待」指的是，如在计数上，应该是 1；在事件上，内部元素触发的事件应该被视作是该节点触发的，等。"
  },
  "Controls whether nodes of this type can be selected as a node selection. Defaults to true for non-text nodes.": {
    "_translate": "控制当前类型的节点是否能够被作为 <a href=\"#state.NodeSelection\">node selection</a> 所选中。 对于非文本节点来说，默认是 true。",
    "_note": ""
  },
  "The attributes that nodes of this type get.": {
    "_translate": "当前节点拿到的 attributes。",
    "_note": ""
  },
  "Determines whether nodes of this type can be dragged without being selected. Defaults to false.": {
    "_translate": "决定在未选中的情况下，当前类型的节点能否被拖拽。默认是 false。",
    "_note": ""
  },
  "Can be used to indicate that this node contains code, which causes some commands to behave differently.": {
    "_translate": "指示当前节点包含 code，其会引起一些命令有特别的行为。",
    "_note": "「特别的行为」如，在 code 节点中的内容如果是 li 和 文档中的 li 是两个处理逻辑，前者针对 code 块处理；后者针对 li 进行处理。"
  },
  "Determines whether this node is considered an important parent node during replace operations (such as paste). Non-defining (the default) nodes get dropped when their entire content is replaced, whereas defining nodes persist and wrap the inserted content.": {
    "_translate": "确定在替换操作（例如粘贴）期间此节点是否被视为重要的父节点。非定义（默认）节点在其全部内容被替换时会被删除，而定义节点则会保留并包裹插入的内容。",
    "_note": "最后一句话讲的是，例如，默认的 paragraph 中，文本块节点，粘贴的时候应该直接替换掉它的父节点，也即另一个文本块。 但是对非默认 paragraph（即你自己定制的 paragraph）的话，在替换内容的时候，就需要保留该 非默认 paragraph 的一些属性，不能直接替换。同理 li 元素， 因为首先选中 li 元素内容，然后粘贴内容是一个很常见的操作，用户的预期是将粘贴内容作为 li 的内容，而不是直接替换掉 li 而粘贴成 paragraph（或其他 block）。"
  },
  "Controls way whitespace in this a node is parsed. The default is \"normal\", which causes the DOM parser to collapse whitespace in normal mode, and normalize it (replacing newlines and such with spaces) otherwise. \"pre\" causes the parser to preserve spaces inside the node. When this option isn't given, but code is true, whitespace will default to \"pre\". Note that this option doesn't influence the way the node is rendered—that should be handled by toDOM and/or styling.": {
    "_translate": "控制此节点中的空白符解析方式。默认值是<code>\"normal\"</code>，这会导致<a href=\"#model.DOMParser\">DOM 解析器</a>在正常模式下折叠空白符，并在其他情况下将其规范化（用空格替换换行符等）。<code>\"pre\"</code>会使解析器保留节点内的空白符。当未提供此选项但<a href=\"#model.NodeSpec.code\"><code>code</code></a>为 true 时，<code>whitespace</code>将默认为<code>\"pre\"</code>。请注意，此选项不会影响节点的渲染方式——这应由<code>toDOM</code>和/或样式处理。",
    "_note": ""
  },
  "In inserted content the defining parents of the content are preserved when possible. Typically, non-default-paragraph textblock types, and possibly list items, are marked as defining.": {
    "_translate": "在插入的内容中，内容的定义父级在可能的情况下会被保留。通常，非默认段落文本块类型，可能还有列表项，会被标记为定义。",
    "_note": ""
  },
  "When enabled, enables both definingAsContext and definingForContent.": {
    "_translate": "启用后，启用 <a href=\"#model.NodeSpec.definingAsContext\"><code>definingAsContext</code></a> 和 <a href=\"#model.NodeSpec.definingForContent\"><code>definingForContent</code></a>。",
    "_note": ""
  },
  "When enabled (default is false), the sides of nodes of this type count as boundaries that regular editing operations, like backspacing or lifting, won't cross. An example of a node that should probably have this enabled is a table cell.": {
    "_translate": "当该属性设置为 true 时（默认是 false），当前类型的节点的两侧将会计算作为边界，于是对于正常的编辑操作如删除、或者提升，将不会被跨越过去。 举个例子，对于 table 的 cell 节点，该属性应该被设置为 true。",
    "_note": "「提升」操作指的是，如在一个二级 li 中，一般用户习惯下，按 shift + tab 会将该二级 li 提升到一级 li。"
  },
  "Defines the default way a node of this type should be serialized to DOM/HTML (as used by DOMSerializer.fromSchema). Should return a DOM node or an array structure that describes one, with an optional number zero (“hole”) in it to indicate where the node's content should be inserted.": {
    "_translate": "定义当前节点的默认序列化成 DOM/HTML 的方式（被<a href=\"#model.DOMSerializer%5EfromSchema\"><code>DOMSerializer.fromSchema</code></a>使用）。 应该返回一个 DOM 节点或者一个描述 ODM 节点的 <a href=\"#model.DOMOutputSpec\">array structure</a>，它带有可选的数字 0 （就是「洞」）， 表示节点的内容应该被插在哪个位置。",
    "_note": ""
  },
  "For text nodes, the default is to create a text DOM node. Though it is possible to create a serializer where text is rendered differently, this is not supported inside the editor, so you shouldn't override that in your text node spec.": {
    "_translate": "对于文本节点，默认是创建一个文本 DOM 节点。虽然创建序列化器以将文本节点特殊渲染是可能的，但是当前编辑器并不支持这样做，因此你不应该覆盖文本节点中的该方法。",
    "_note": ""
  },
  "Defines the default way a node of this type should be serialized to a string representation for debugging (e.g. in error messages).": {
    "_translate": "定义一个该类型节点被序列化成一个字符串形式的默认方法，以做 debugging 用途。",
    "_note": ""
  },
  "Associates DOM parser information with this node, which can be used by DOMParser.fromSchema to automatically derive a parser. The node field in the rules is implied (the name of this node will be filled in automatically). If you supply your own parser, you do not need to also specify parsing rules in your schema.": {
    "_translate": "当前节点相关的 DOM parser 信息，会被 <a href=\"#model.DOMParser%5EfromSchema\"><code>DOMParser.fromSchema</code></a> 使用以自动的衍生出一个 parser。Rule 中的 <code>node</code> 字段是隐式的（节点的名字会自动填充）。如果你在此处提供了自己的 parser，那你就不需要再在 schema 配置的时候提供 parser 了。",
    "_note": "配置 Editor view 的时候可以配置一个 Parser 和 Serializer，如果提供，则此处就不用写 parseDOM 了。"
  },
  "Defines the default way a leaf node of this type should be serialized to a string (as used by Node.textBetween and Node.textContent).": {
    "_translate": "定义了这种类型的<a href=\"#model.NodeType.isLeaf\">叶节点</a>序列化为字符串的默认方式（由<a href=\"#model.Node%5EtextBetween\"><code>Node.textBetween</code></a>和<a href=\"#model.Node%5EtextContent\"><code>Node.textContent</code></a>使用）。",
    "_note": ""
  },
  "Node specs may include arbitrary properties that can be read by other code via NodeType.spec.": {
    "_translate": "节点规格可能包括任意属性，这些属性可以通过<a href=\"#model.NodeType.spec\"><code>NodeType.spec</code></a>被其他代码读取。",
    "_note": ""
  },
  "A single inline node in a schema can be set to be a linebreak equivalent. When converting between block types that support the node and block types that don't but have whitespace set to \"pre\", setBlockType will convert between newline characters to or from linebreak nodes as appropriate.": {
    "_translate": "在模式中，单个内联节点可以设置为换行符等效项。在支持该节点的块类型和不支持但具有<a href=\"#model.NodeSpec.whitespace\"><code>whitespace</code></a>设置为<code>\"pre\"</code>的块类型之间进行转换时，<a href=\"#transform.Transform.setBlockType\"><code>setBlockType</code></a>将适当地在换行符和换行节点之间进行转换。",
    "_note": ""
  },
  "Used to define marks when creating a schema.": {
    "_translate": "用于在创建模式时定义标记。",
    "_note": ""
  },
  "The attributes that marks of this type get.": {
    "_translate": "当前 mark 类型拿到的 attributes。",
    "_note": ""
  },
  "Whether this mark should be active when the cursor is positioned at its end (or at its start when that is also the start of the parent node). Defaults to true.": {
    "_translate": "当光标放到该 mark 的结尾处（或者如果该 mark 开始处同样是父级节点的开始处时，放到 mark 的开始处）时，该 marks 是否应该被激活。默认是 true/",
    "_note": "「被激活」的意思是，可以通过 API 获取光标所在的 resolvedPos 信息以查到相关的 marks，对用户来说被激活意味着在该地方输入内容会带上相应的 marks。"
  },
  "Determines which other marks this mark can coexist with. Should be a space-separated strings naming other marks or groups of marks. When a mark is added to a set, all marks that it excludes are removed in the process. If the set contains any mark that excludes the new mark but is not, itself, excluded by the new mark, the mark can not be added an the set. You can use the value \"_\" to indicate that the mark excludes all marks in the schema.": {
    "_translate": "决定当前 mark 是否能和其他 marks 共存。应该是由其他 marks 名或者 marks group 组成的以空格分隔的字符串。 当一个 marks 被 <a href=\"#model.Mark.addToSet\">added</a> 到一个集合中时，所有的与此 marks 排斥（excludes）的 marks 将会被在添加过程中移除。 如果当前集合包含任何排斥当前的新 mark 的 mark，但是该新 mark 却不排斥它，则当前新的 mark 不会被添加到集合中。你可以使用 <code>\"_\"</code> 来表明当前 marks 排斥所有的 schema 中的其他 marks。",
    "_note": "该段的主要意思是，第一：假设 A 、B 互斥，则 无论 A 添加到包含 B 的集合，还是 B 添加到 包含 A 的集合，已经在集合中的一方会被移除以添加新的 mark； 第二：若假设 A 排斥 B，B 却不排斥 A，则将 B 添加到包含 A 的集合中去的时候，将不会被添加进去。"
  },
  "Defaults to only being exclusive with marks of the same type. You can set it to an empty string (or any string not containing the mark's own name) to allow multiple marks of a given type to coexist (as long as they have different attributes).": {
    "_translate": "默认是相同类型的 marks 会互斥。你可以将其设置为一个空的字符串（或者任何不包含 mark 自身名字的字符串） 以允许给定相同类型的多个 marks 共存（之哟啊他们有不同的 attributes）。",
    "_note": ""
  },
  "The group or space-separated groups to which this mark belongs.": {
    "_translate": "当前 mark 所属的 一个 group 或者空格分隔的多个 groups。",
    "_note": ""
  },
  "Determines whether marks of this type can span multiple adjacent nodes when serialized to DOM/HTML. Defaults to true.": {
    "_translate": "决定当序列化为 DOM/HTML 的时候，当前类型的 marks 能否应用到相邻的多个节点上去。默认是 true。",
    "_note": ""
  },
  "Defines the default way marks of this type should be serialized to DOM/HTML. When the resulting spec contains a hole, that is where the marked content is placed. Otherwise, it is appended to the top node.": {
    "_translate": "定义当前类型的 marks 序列化为 DOM/HTML 的默认方式。如果结果配置对象包含一个「洞」，则洞的位置就是 mark 内容所在的位置。否则，它会被附加到顶级节点之后。",
    "_note": "「否则，它会被附加到顶级节点之后」字面意思吗？有待实验，本人貌似没有印象了。"
  },
  "Associates DOM parser information with this mark (see the corresponding node spec field). The mark field in the rules is implied.": {
    "_translate": "当前 mark 的相关的 DOM parser 信息（具体请查看相应的 <a href=\"#model.NodeSpec.parseDOM\">node spec field</a>）。 在 Rules 中的 <code>mark</code> 字段是隐式的。",
    "_note": ""
  },
  "Mark specs can include additional properties that can be inspected through MarkType.spec when working with the mark.": {
    "_translate": "Mark 规格可以包括其他属性，这些属性可以在使用标记时通过 <a href=\"#model.MarkType.spec\"><code>MarkType.spec</code></a> 进行检查。",
    "_note": ""
  },
  "Used to define attributes on nodes or marks.": {
    "_translate": "用来 <a href=\"#model.NodeSpec.attrs\">define</a> node 或者 marks 的 attributes。",
    "_note": ""
  },
  "The default value for this attribute, to use when no explicit value is provided. Attributes that have no default must be provided whenever a node or mark of a type that has them is created.": {
    "_translate": "该 attribute 的默认值，当没有显式提供值的时候使用。如果 attributes 没有默认值，则必须在新建一个 node 或者 mark 的时候提供值。",
    "_note": ""
  },
  "A function or type name used to validate values of this attribute. This will be used when deserializing the attribute from JSON, and when running Node.check. When a function, it should raise an exception if the value isn't of the expected type or shape. When a string, it should be a |-separated string of primitive types (\"number\", \"string\", \"boolean\", \"null\", and \"undefined\"), and the library will raise an error when the value is not one of those types.": {
    "_translate": "用于验证此属性值的函数或类型名称。这将在从 JSON 反序列化属性时使用，并在运行 <a href=\"#model.Node.check\"><code>Node.check</code></a> 时使用。当是一个函数时，如果值不是预期的类型或形状，则应引发异常。当是一个字符串时，它应该是一个由原始类型（<code>\"number\"</code>、<code>\"string\"</code>、<code>\"boolean\"</code>、<code>\"null\"</code> 和 <code>\"undefined\"</code>）组成的用 <code>|</code> 分隔的字符串，并且当值不是这些类型之一时，库将引发错误。",
    "_note": ""
  },
  "Node types are objects allocated once per Schema and used to tag Node instances. They contain information about the node type, such as its name and what kind of node it represents.": {
    "_translate": "每个 Node Type 只会被 Schema 初始化一次，然后使用它来<a href=\"#model.Node.type\">tag（归类）</a> <code>Node</code> 的实例。 这种对象包含了节点的类型信息，比如名称以及它表示那种节点。",
    "_note": ""
  },
  "The name the node type has in this schema.": {
    "_translate": "该节点类型在 schema 中的名称。",
    "_note": ""
  },
  "A link back to the Schema the node type belongs to.": {
    "_translate": "一个指向节点类型所属 <code>Schema</code> 的指针。",
    "_note": ""
  },
  "The spec that this type is based on": {
    "_translate": "当前类型的配置对象。",
    "_note": ""
  },
  "True if this node type has inline content.": {
    "_translate": "如果当前节点类型有内联内容的话，即为 true。",
    "_note": ""
  },
  "True if this is a block type": {
    "_translate": "当前节点是块级类型的话，即为 true。",
    "_note": "判断是否是块级类型是用排除法，如果不是内联类型（即 spec.inline 是 false）且节点类型的名称不是「text」，则该类型是块级类型。"
  },
  "True if this is the text node type.": {
    "_translate": "如果是文本类型的节点，即为 true。",
    "_note": "也即节点名字是「text」。"
  },
  "True if this is an inline type.": {
    "_translate": "如果是一个内联类型，则为 true。",
    "_note": "同样使用排除法，即与 spec.isBlock 互斥。"
  },
  "True if this is a textblock type, a block that contains inline content.": {
    "_translate": "如果节点是文本块类型节点则为 true，即一个包含内联内容的块级类型节点。",
    "_note": "一个块级类型可能包含另一个块级类型，一个文本块类型则只会包含内联内容，哪些节点是内联元素由 schema 决定。"
  },
  "True for node types that allow no content.": {
    "_translate": "如果节点不允许内容，则为 true。",
    "_note": "是否是叶节点使用的是 spec.contentMatch 是否为空判断的。"
  },
  "True when this node is an atom, i.e. when it does not have directly editable content.": {
    "_translate": "如果节点是一个原子节点则为 true，例如，一个没有直接可编辑的内容的节点。",
    "_note": ""
  },
  "Return true when this node type is part of the given group.": {
    "_translate": "当此节点类型是给定的<a href=\"#model.NodeSpec.group\">组</a>的一部分时返回 true。",
    "_note": ""
  },
  "The starting match of the node type's content expression.": {
    "_translate": "节点类型内容表达式的起始匹配。",
    "_note": "sorry，这个 contentMatch 我用的比较少，所以也不知道是什么意思，貌似源码内部使用的比较多。"
  },
  "The set of marks allowed in this node. null means all marks are allowed.": {
    "_translate": "该节点中允许的标记集。<code>null</code>表示允许所有标记。",
    "_note": ""
  },
  "The node type's whitespace option.": {
    "_translate": "节点类型的<a href=\"#model.NodeSpec.whitespace\">空白</a>选项。",
    "_note": ""
  },
  "Tells you whether this node type has any required attributes.": {
    "_translate": "告诉你该节点类型是否有任何必须的 attributes。",
    "_note": ""
  },
  "Indicates whether this node allows some of the same content as the given node type.": {
    "_translate": "指示此节点是否允许与给定节点类型相同的一些内容。",
    "_note": ""
  },
  "Create a Node of this type. The given attributes are checked and defaulted (you can pass null to use the type's defaults entirely, if no required attributes exist). content may be a Fragment, a node, an array of nodes, or null. Similarly marks may be null to default to the empty set of marks.": {
    "_translate": "新建一个此种类型的节点。将会检查给定的 attributes，未给定的话即为默认值（如果该中类型的节点没有任何必须的 attributes，你可以直接传递 <code>null</code> 来使用全部 attributes 的默认值）。 <code>content</code> 可能是一个 <code>Fragment</code>、一个节点、一个节点数组或者 <code>null</code>。<code>marks</code> 参数与之类似，默认是 <code>null</code>，表示空的 marks 集合。",
    "_note": ""
  },
  "Like create, but check the given content against the node type's content restrictions, and throw an error if it doesn't match.": {
    "_translate": "与 <a href=\"#model.NodeType.create\"><code>create</code></a> 类似，但是会检查给定的 content 是否符合节点类型的内容限制，如果不符的话会抛出一个错误。",
    "_note": "该自定义错误类型为 RangeError。"
  },
  "Like create, but see if it is necessary to add nodes to the start or end of the given fragment to make it fit the node. If no fitting wrapping can be found, return null. Note that, due to the fact that required nodes can always be created, this will always succeed if you pass null or Fragment.empty as content.": {
    "_translate": "和 <a href=\"#model.NodeType.create\"><code>create</code></a> 类似，不过该方法会查看是否有必要在给定的 fragment 开始和结尾的地方 添加一些节点，以让该 fragment 适应当前 node。如果没有找到合适的包裹节点，则返回 null。 记住，如果你传递 <code>null</code> 或者 <code>Fragment.empty</code> 作为内容会导致其一定会适合当前 node，因此该方法一定会成功。",
    "_note": "因为 null 和 Fragment.empty 不用寻找任何「合适的包裹节点」就能适应当前节点。"
  },
  "Returns true if the given fragment is valid content for this node type.": {
    "_translate": "如果给定的片段是此节点类型的有效内容，则返回 true",
    "_note": ""
  },
  "Check whether the given mark type is allowed in this node.": {
    "_translate": "检查当前节点类型是否允许给定的 mark 类型。",
    "_note": ""
  },
  "Test whether the given set of marks are allowed in this node.": {
    "_translate": "检查当前节点类型是否允许给定的 marks 集合。",
    "_note": ""
  },
  "Removes the marks that are not allowed in this node from the given set.": {
    "_translate": "从给定的 marks 集合中移除不允许出现在当前 node 中的 marks。",
    "_note": ""
  },
  "Like nodes, marks (which are associated with nodes to signify things like emphasis or being part of a link) are tagged with type objects, which are instantiated once per Schema.": {
    "_translate": "和 nodes 类似，marks（与 node 关联的以表示诸如强调、链接等的内容）也被用类型对象进行 <a href=\"#model.Mark.type\">tagged（归类）</a>， 每个类型只会被 <code>Schema</code> 实例化一次。",
    "_note": ""
  },
  "The name of the mark type.": {
    "_translate": "mark 类型的名称。",
    "_note": ""
  },
  "The schema that this mark type instance is part of.": {
    "_translate": "当前 mark 类型所属于的 schema。",
    "_note": ""
  },
  "The spec on which the type is based.": {
    "_translate": "当前 mark 类型的配置对象。",
    "_note": ""
  },
  "Create a mark of this type. attrs may be null or an object containing only some of the mark's attributes. The others, if they have defaults, will be added.": {
    "_translate": "创建一个当前类型的 mark。<code>attrs</code> 可能是 <code>null</code> 或者是一个仅包含部分 marks attributes 的对象。 其他未包含的 attributes，会使用它们的默认值添加上去。",
    "_note": ""
  },
  "When there is a mark of this type in the given set, a new set without it is returned. Otherwise, the input set is returned.": {
    "_translate": "如果当前 mark 类型存在与给定的 mark 集合，则将会返回不含有当前 mark 类型的 marks 集合。 否则，直接返回给定的 marks 集合。",
    "_note": "看函数名，顾名思义就是在给定 marks 集合中移除当前 mark 类型的 marks。"
  },
  "Tests whether there is a mark of this type in the given set.": {
    "_translate": "检查当前类型的 marks 是否存在于给定 marks 集合。",
    "_note": ""
  },
  "Queries whether a given mark type is excluded by this one.": {
    "_translate": "查询给定的 mark 类型是否与当前 mark 类型 <a href=\"#model.MarkSpec.excludes\">excluded（互斥）</a>",
    "_note": ""
  },
  "Instances of this class represent a match state of a node type's content expression, and can be used to find out whether further content matches here, and whether a given position is a valid end of the node.": {
    "_translate": "该类的实例表示一个节点类型的 <a href=\"#model.NodeSpec.content\">content expression（内容表达式）</a> 的匹配状态， 其可以用来寻找是否此处是否有更进一步的内容能够匹配到，以及判断一个位置是否是该节点的可用的结尾。",
    "_note": "本小节的方法和类我用的不多，可能在处理一些边缘 case 的情况才会用到，因此很多直译了。"
  },
  "True when this match state represents a valid end of the node.": {
    "_translate": "当匹配状态表示该节点有一个可用的结尾时为 true。",
    "_note": ""
  },
  "Match a node type, returning a match after that node if successful.": {
    "_translate": "匹配一个节点类型，如果成功则返回该 ContentMatch 匹配结果。",
    "_note": ""
  },
  "Try to match a fragment. Returns the resulting match when successful.": {
    "_translate": "尝试去匹配一个 fragment。如果成功则返回 ContentMatch 匹配结果。",
    "_note": ""
  },
  "Get the first matching node type at this match position that can be generated.": {
    "_translate": "获取相应匹配位置的第一个可以被生成的匹配节点类型。",
    "_note": "「可以被生成的」指的是该位置不能是文本节点或者不能有必须存在的 attribute 才能被生成。"
  },
  "Try to match the given fragment, and if that fails, see if it can be made to match by inserting nodes in front of it. When successful, return a fragment of inserted nodes (which may be empty if nothing had to be inserted). When toEnd is true, only return a fragment if the resulting match goes to the end of the content expression.": {
    "_translate": "尝试匹配给定的 fragment，如果失败，则会查看是否可以通过在该 fragment 前面插入一些节点来使之匹配。 如果插入节点后匹配成功，则会返回一个插入的节点组成的 fragment（如果没有需要插入的节点，则可能是空的）。 当 <code>toEnd</code> 为 true 时，只有结果匹配到达了内容表达式的结尾之时，才会返回一个 fragment。",
    "_note": "否则返回 undefined。"
  },
  "Find a set of wrapping node types that would allow a node of the given type to appear at this position. The result may be empty (when it fits directly) and will be null when no such wrapping exists.": {
    "_translate": "寻找一个包裹给定节点的节点集合，该集合中的节点在包裹住给定类型的节点后才能出现在当前位置。 集合的内容可能是空（如果给定类型节点直接就适合当前位置而无需包裹任何节点时），若不存在相应的包裹节点，则集合也可能是 null。",
    "_note": ""
  },
  "The number of outgoing edges this node has in the finite automaton that describes the content expression.": {
    "_translate": "在描述内容表达式的有限自动机中该节点拥有的外部边界的数量。",
    "_note": "没理解什么意思，需要看源码，我直译的，鼠标悬浮查看原始文档。"
  },
  "Get the _n_​th outgoing edge from this node in the finite automaton that describes the content expression.": {
    "_translate": "在描述内容表达式的有限自动机中获取该节点第 <em>n</em> 个外部的边界。",
    "_note": ""
  },
  "Because representing a document as a tree of DOM nodes is central to the way ProseMirror operates, DOM parsing and serializing is integrated with the model.": {
    "_translate": "由于用一颗 DOM 节点树来表示一个文档是 ProseMirror 进行各种操作的核心思想，因此 DOM <a href=\"#model.DOMParser\">parsing</a> 和 <a href=\"#model.DOMSerializer\">serializing</a> 被集成进该模块中。",
    "_note": ""
  },
  "(But note that you do not need to have a DOM implementation loaded to use this module.)": {
    "_translate": "（不过记住，你 <em>不需要</em> 使用该模块来实现一个 DOM 操作接口。）",
    "_note": ""
  },
  "A DOM parser represents a strategy for parsing DOM content into a ProseMirror document conforming to a given schema. Its behavior is defined by an array of rules.": {
    "_translate": "一个为了让 ProseMirror 文档符合给定 schema 的 Parser。它的行为由一个 <a href=\"#model.ParseRule\">rules</a> 数组定义。",
    "_note": ""
  },
  "Create a parser that targets the given schema, using the given parsing rules.": {
    "_translate": "新建一个针对给定 schema 的 parser，使用给定的 parsing rules。",
    "_note": ""
  },
  "The schema into which the parser parses.": {
    "_translate": "parser 所 parses 的 schema。",
    "_note": "解析器所解析的 schema。"
  },
  "The set of parse rules that the parser uses, in order of precedence.": {
    "_translate": "parser 所使用的 <a href=\"#model.ParseRule\">parse rules</a>，按顺序优先。",
    "_note": ""
  },
  "Parse a document from the content of a DOM node.": {
    "_translate": "parse 一个 DOM 节点的内容成一个文档。",
    "_note": ""
  },
  "Parses the content of the given DOM node, like parse, and takes the same set of options. But unlike that method, which produces a whole node, this one returns a slice that is open at the sides, meaning that the schema constraints aren't applied to the start of nodes to the left of the input and the end of nodes at the end.": {
    "_translate": "parses 给定的 DOM 节点，与 <a href=\"#model.DOMParser.parse\"><code>parse</code></a> 类似，接受与之相同的参数。 不过与 parse 方法产生一整个节点不同的是，这个方法返回一个在节点两侧打开的 slice，这意味着 schema 的约束不适用于输入节点左侧节点的开始位置和末尾节点的结束位置。",
    "_note": "这表示该方法可能产生一个不受 schema 约束的 node，只是该 node 由于 openStart 和 openEnd 的存在而适合 schema （被 open 剪切掉以适合 schema，但是整体不适合 schema）。"
  },
  "Construct a DOM parser using the parsing rules listed in a schema's node specs, reordered by priority.": {
    "_translate": "用给定的 schema 中的 <a href=\"#model.NodeSpec.parseDOM\">node 配置对象</a> 中的 parsing rule 来构造一个 DOM parser， 被按 <a href=\"#model.ParseRule.priority\">优先级</a> 重新排序。",
    "_note": ""
  },
  "These are the options recognized by the parse and parseSlice methods.": {
    "_translate": "这是一个被 <a href=\"#model.DOMParser.parse\"><code>parse</code></a> 和 <a href=\"#model.DOMParser.parseSlice\"><code>parseSlice</code></a> 方法用到的参数配置对象。",
    "_note": ""
  },
  "By default, whitespace is collapsed as per HTML's rules. Pass true to preserve whitespace, but normalize newlines to spaces, and \"full\" to preserve whitespace entirely.": {
    "_translate": "默认情况下，根据 HTML 的规则，空白符会被折叠起来不显示。传递 <code>true</code> 表示保留空白符，但会将换行符表示为空格。 <code>\"full\"</code> 表示完全保留所有的空白符。",
    "_note": ""
  },
  "When given, the parser will, beside parsing the content, record the document positions of the given DOM positions. It will do so by writing to the objects, adding a pos property that holds the document position. DOM positions that are not in the parsed content will not be written to.": {
    "_translate": "如果设置了该参数，则 parser 除了 parsing 内容外，还将记录给定位置 DOM 在文档中相应的位置。 它将通过写入对象，添加一个保存文档位置的 <code>pos</code> 属性来实现。不在 parsed 内容中的 DOM 的位置将不会被写入。",
    "_note": ""
  },
  "The child node index to start parsing from.": {
    "_translate": "从开始 parsing 位置计算的子节点的索引。",
    "_note": ""
  },
  "The child node index to stop parsing at.": {
    "_translate": "从结束 parsing 位置计算的子节点的索引。",
    "_note": ""
  },
  "By default, the content is parsed into the schema's default top node type. You can pass this option to use the type and attributes from a different node as the top container.": {
    "_translate": "默认情况下，内容会被 parsed 到 schema 的默认 <a href=\"#model.Schema.topNodeType\">顶级节点</a> 中。 你可以传递这个选项和 attributes 以使用一个不同的节点作为顶级容器。",
    "_note": ""
  },
  "Provide the starting content match that content parsed into the top node is matched against.": {
    "_translate": "提供与 parsed 到顶级节点的内容匹配的起始内容匹配。",
    "_note": ""
  },
  "A set of additional nodes to count as context when parsing, above the given top node.": {
    "_translate": "在 parsing 的时候的一个额外的节点集合，其被算作给定 <a href=\"#model.ParseOptions.topNode\">top node</a> 之上的 <a href=\"#model.ParseRule.context\">context</a>。",
    "_note": ""
  },
  "Fields that may be present in both tag and style parse rules.": {
    "_translate": "在<a href=\"#model.TagParseRule\">标签</a>和<a href=\"#model.StyleParseRule\">样式</a>解析规则中可能存在的字段。",
    "_note": ""
  },
  "Can be used to change the order in which the parse rules in a schema are tried. Those with higher priority come first. Rules without a priority are counted as having priority 50. This property is only meaningful in a schema—when directly constructing a parser, the order of the rule array is used.": {
    "_translate": "可以使用它来提升 schema 中 parse rule 的优先级顺序。更高优先级的更先被 parse。 没有优先级设置的 rule 则被默认设置一个 50 的优先级。该属性只在 schema 中才有意义。 而在直接构造一个 parser 的时候使用的是 rule 数组的顺序。",
    "_note": ""
  },
  "By default, when a rule matches an element or style, no further rules get a chance to match it. By setting this to false, you indicate that even when this rule matches, other rules that come after it should also run.": {
    "_translate": "默认情况下，如果一个 rule 匹配了一个元素或者样式，那么就不会进一步的匹配接下来的 rule 了。 而通过设置该参数为 <code>false</code>，你可以决定即使当一个 rule 匹配了，在该 rule 之后的 rule 也依然会运行一次。",
    "_note": ""
  },
  "The name of the mark type to wrap the matched content in.": {
    "_translate": "包裹匹配内容的 mark 类型的名字。",
    "_note": ""
  },
  "When given, restricts this rule to only match when the current context—the parent nodes into which the content is being parsed—matches this expression. Should contain one or more node names or node group names followed by single or double slashes. For example \"paragraph/\" means the rule only matches when the parent node is a paragraph, \"blockquote/paragraph/\" restricts it to be in a paragraph that is inside a blockquote, and \"section//\" matches any position inside a section—a double slash matches any sequence of ancestor nodes. To allow multiple different contexts, they can be separated by a pipe (|) character, as in \"blockquote/|list_item/\".": {
    "_translate": "如果设置了该属性，则限制 rule 只匹配给定的上下文表达式，该上下文即为被 parsed 的内容所在的父级节点。 应该包含一个或者多个节点名或者节点 group 名，用一个或者两个斜杠结尾。例如 <code>\"paragraph/\"</code> 表示只有当父级节点是段落的时候才会被匹配， <code>\"blockquote/paragraph/\"</code> 限制只有在一个 blockquote 中的一个段落中才会被匹配，<code>\"section//\"</code> 表示匹配在一个 section 中的任何位置--一个双斜线表示匹配 任何祖先节点序列。为了允许多个不同的上下文，它们可以用 <code>|</code> 分隔，比如 <code>\"blockquote/|list_item/\"</code>。",
    "_note": ""
  },
  "When true, ignore content that matches this rule.": {
    "_translate": "如果是 true，则当前 rule 的内容会被忽略。",
    "_note": ""
  },
  "When true, finding an element that matches this rule will close the current node.": {
    "_translate": "如果是 true，则会在寻找匹配该 rule 的元素的时候关闭当前节点。",
    "_note": ""
  },
  "When true, ignore the node that matches this rule, but do parse its content.": {
    "_translate": "如果是 true，则会忽略匹配当前规则的节点，但是会 parse 它的内容。",
    "_note": ""
  },
  "Attributes for the node or mark created by this rule. When getAttrs is provided, it takes precedence.": {
    "_translate": "由该 rule 创建的节点或者 mark 的 attributes。如果 <code>getAttrs</code> 存在的话，<code>getAttrs</code> 优先。",
    "_note": ""
  },
  "Parse rule targeting a DOM element.": {
    "_translate": "解析规则定位一个DOM元素。",
    "_note": ""
  },
  "A CSS selector describing the kind of DOM elements to match.": {
    "_translate": "描述要匹配的DOM元素类型的CSS选择器。",
    "_note": ""
  },
  "The namespace to match. Nodes are only matched when the namespace matches or this property is null.": {
    "_translate": "要匹配的命名空间。仅当命名空间匹配或此属性为 null 时才匹配节点。",
    "_note": ""
  },
  "The name of the node type to create when this rule matches. Each rule should have either a node, mark, or ignore property (except when it appears in a node or mark spec, in which case the node or mark property will be derived from its position).": {
    "_translate": "匹配此规则时要创建的节点类型的名称。每个规则应具有<code>node</code>、<code>mark</code>或<code>ignore</code>属性（除非它出现在<a href=\"#model.NodeSpec.parseDOM\">node</a>或<a href=\"#model.MarkSpec.parseDOM\">mark spec</a>中，在这种情况下，<code>node</code>或<code>mark</code>属性将从其位置派生）。",
    "_note": ""
  },
  "A function used to compute the attributes for the node or mark created by this rule. Can also be used to describe further conditions the DOM element or style must match. When it returns false, the rule won't match. When it returns null or undefined, that is interpreted as an empty/default set of attributes.": {
    "_translate": "用来计算由当前 rule 新建的节点或者 mark 的 attributes。也可以用来描述进一步 DOM 元素或者行内样式匹配的话需要满足的条件。 当它返回 <code>false</code>，则 rule 不会匹配。当它返回 null 或者 undefined，则被当成是一个空的/默认的 attributes 集合。",
    "_note": ""
  },
  "Can be used to override the content of a matched node. When present, instead of parsing the node's child nodes, the result of this function is used.": {
    "_translate": "如果设置了该方法，则会使用函数返回的结果来作为匹配节点的内容，而不是 parsing 节点的子节点。",
    "_note": ""
  },
  "For rules that produce non-leaf nodes, by default the content of the DOM element is parsed as content of the node. If the child nodes are in a descendent node, this may be a CSS selector string that the parser must use to find the actual content element, or a function that returns the actual content element to the parser.": {
    "_translate": "对于生成非叶节点的规则，默认情况下，DOM 元素的内容会被解析为节点的内容。如果子节点位于后代节点中，这可能是解析器必须使用的 CSS 选择器字符串，以找到实际的内容元素，或者是一个返回实际内容元素给解析器的函数。",
    "_note": ""
  },
  "A parse rule targeting a style property.": {
    "_translate": "一个解析规则，目标是一个样式属性。",
    "_note": ""
  },
  "Controls whether whitespace should be preserved when parsing the content inside the matched element. false means whitespace may be collapsed, true means that whitespace should be preserved but newlines normalized to spaces, and \"full\" means that newlines should also be preserved.": {
    "_translate": "控制当 parsing 匹配元素的内容的时候，空白符是否应该保留。<code>false</code> 表示空白符应该不显示， <code>true</code> 表示空白符应该不显示但是换行符会被换成空格，<code>\"full\"</code> 表示换行符也应该被保留。",
    "_note": ""
  },
  "A CSS property name to match. This rule will match inline styles that list that property. May also have the form \"property=value\", in which case the rule only matches if the property's value exactly matches the given value. (For more complicated filters, use getAttrs and return false to indicate that the match failed.) Rules matching styles may only produce marks, not nodes.": {
    "_translate": "一个要匹配的CSS属性名称。此规则将匹配列出该属性的内联样式。也可以采用<code>\"property=value\"</code>的形式，在这种情况下，只有当属性的值完全匹配给定值时，规则才会匹配。（对于更复杂的过滤器，请使用<a href=\"#model.ParseRule.getAttrs\"><code>getAttrs</code></a>并返回false以指示匹配失败。）匹配样式的规则只能生成<a href=\"#model.ParseRule.mark\">marks</a>，而不是节点。",
    "_note": ""
  },
  "Style rules can remove marks from the set of active marks.": {
    "_translate": "样式规则可以从活动标记集中移除标记。",
    "_note": ""
  },
  "A function used to compute the attributes for the node or mark created by this rule. Called with the style's value.": {
    "_translate": "用于计算由此规则创建的节点或标记属性的函数。使用样式的值调用。",
    "_note": ""
  },
  "A value that describes how to parse a given DOM node or inline style as a ProseMirror node or mark.": {
    "_translate": "一个描述了如何 parse 给定 DOM 节点及行内样式成 ProseMirror 节点及 mark 的对象。",
    "_note": ""
  },
  "A DOM serializer knows how to convert ProseMirror nodes and marks of various types to DOM nodes.": {
    "_translate": "一个 DOM serializer 知道如何将不同类型的 ProseMirror 节点和 marks 转换成 DOM 节点。",
    "_note": ""
  },
  "Create a serializer. nodes should map node names to functions that take a node and return a description of the corresponding DOM. marks does the same for mark names, but also gets an argument that tells it whether the mark's content is block or inline content (for typical use, it'll always be inline). A mark serializer may be null to indicate that marks of that type should not be serialized.": {
    "_translate": "新建一个 serializer。<code>nodes</code> 应该是一个对象，键是节点名，值是一个函数，函数接受一个节点作为参数，返回相应的 DOM 描述。 <code>marks</code> 类似，键值 marks 名，值是一个函数，只不过函数参数表示的是 marks 的内容是否是 block 的或者是 inline 的（一般情况下应该是 inline 的）。 一个 mark serializer 可能是 <code>null</code>，表示这种类型的 mark 不应该被 serialized（序列化）。",
    "_note": ""
  },
  "The node serialization functions.": {
    "_translate": "节点的 serialization 函数们。",
    "_note": ""
  },
  "The mark serialization functions.": {
    "_translate": "mark 的 serialization 函数们。",
    "_note": ""
  },
  "Serialize the content of this fragment to a DOM fragment. When not in the browser, the document option, containing a DOM document, should be passed so that the serializer can create nodes.": {
    "_translate": "将给定的 fragment serialize 成 DOM fragment。如果该操作不是在浏览器中完成， 那么应该传递一个 <code>document</code> 参数，以让 serializer 能够新建 nodes 们。",
    "_note": "即 option.document，如果没有传，默认使用的是 window.document。"
  },
  "Serialize this node to a DOM node. This can be useful when you need to serialize a part of a document, as opposed to the whole document. To serialize a whole document, use serializeFragment on its content.": {
    "_translate": "将节点 serialize 成一个 DOM 节点。这对于当想要 serialize 文档的一部分而不是整个文档的时候很有用。 若要 serialize 整个文档，在它的 <a href=\"#model.Node.content\">content</a> 属性上调用 <a href=\"#model.DOMSerializer.serializeFragment\"><code>serializeFragment</code></a> 来完成。",
    "_note": ""
  },
  "Render an output spec to a DOM node. If the spec has a hole (zero) in it, contentDOM will point at the node with the hole.": {
    "_translate": "渲染一个 <a href=\"#model.DOMOutputSpec\">output 配置对象</a> 到一个 DOM 节点。如果配置对象有一个洞（数字0）， 则 <code>contentDOM</code> 将会指向该洞所代表的节点。",
    "_note": ""
  },
  "Build a serializer using the toDOM properties in a schema's node and mark specs.": {
    "_translate": "使用 schema 中节点和 mark 配置对象的 <a href=\"#model.NodeSpec.toDOM\"><code>toDOM</code></a> 方法来构建一个 serializer。",
    "_note": ""
  },
  "Gather the serializers in a schema's node specs into an object. This can be useful as a base to build a custom serializer from.": {
    "_translate": "将模式的节点规范中的序列化器收集到一个对象中。 这可以作为构建自定义序列化器的基础。",
    "_note": ""
  },
  "Gather the serializers in a schema's mark specs into an object.": {
    "_translate": "将模式的标记规范中的序列化器收集到一个对象中。",
    "_note": ""
  },
  "A description of a DOM structure. Can be either a string, which is interpreted as a text node, a DOM node, which is interpreted as itself, a {dom, contentDOM} object, or an array.": {
    "_translate": "对DOM结构的描述。可以是一个字符串，它被解释为一个文本节点，一个DOM节点，它被解释为自身，一个<code>{dom, contentDOM}</code>对象，或一个数组。",
    "_note": ""
  },
  "An array describes a DOM element. The first value in the array should be a string—the name of the DOM element, optionally prefixed by a namespace URL and a space. If the second element is plain object, it is interpreted as a set of attributes for the element. Any elements after that (including the 2nd if it's not an attribute object) are interpreted as children of the DOM elements, and must either be valid DOMOutputSpec values, or the number zero.": {
    "_translate": "这个数组描述了一个 DOM 元素。数组中的第一个值应该是这个 DOM 元素名字字符串，可以允许带上命名空间 URL 的前缀或者空格。 如果数组第二个值是一个普通对象，则被当做是 DOM 元素的 attributes。在数组第二个值之后的任何值（包括第二个值，如果它不是一个普通属性对象的话） 都被认为是该 DOM 元素的子元素，因此这些后面的值必须是有一个有效的 <code>DOMOutputSpec</code> 值，或者是数字 0。",
    "_note": ""
  },
  "The number zero (pronounced “hole”) is used to indicate the place where a node's child nodes should be inserted. If it occurs in an output spec, it should be the only child element in its parent node.": {
    "_translate": "数字 0（念做「洞」）被用来指示子元素应该被放置的位置。如果子元素是一个会被放置内容的节点，那么 0 应该是它唯一子元素。",
    "_note": "举个例子： ['div', {style:'color:red'}, 0]，表示的是 &lt;div style=\"color:red\"&gt;子元素&lt;div&gt;; ['div', {style:'color:red'}, ['p', 0]]，表示的是 &lt;div style=\"color:red\"&gt;&lt;p&gt;子元素&lt;/p&gt;&lt;div&gt;; ['div', {style:'color:red'}, ['p'], 0] 非法，因为 0 作为一个放置子元素的容器，其并不是父节点 div 的唯一子元素，父节点还有个子元素是 p。"
  },
  "This module defines a way of modifying documents that allows changes to be recorded, replayed, and reordered. You can read more about transformations in the guide.": {
    "_translate": "这个模块定义了一种修改文档的方式，以允许修改被记录、回放、重新排序。你可以在 <a href=\"https://xheldon.com/prosemirror-guide-chinese.html#document-transformations\">中文指南</a> 了解更多。",
    "_note": ""
  },
  "Transforming happens in Steps, which are atomic, well-defined modifications to a document. Applying a step produces a new document.": {
    "_translate": "Transforming 发生在一个或者多个 <code>Step</code> 中，step 是原子的及定义良好的一个修改文档的类。 <a href=\"#transform.Step.apply\">Applying（应用）</a> 一个 step 会产生一个新的文档。",
    "_note": ""
  },
  "Each step provides a change map that maps positions in the old document to position in the transformed document. Steps can be inverted to create a step that undoes their effect, and chained together in a convenience object called a Transform.": {
    "_translate": "每个 step 提供一个 <a href=\"#transform.StepMap\">change map（修改映射）</a>，它会在旧的文档和 transformed 后的文档之间映射。 Steps 可以被 <a href=\"#transform.Step.invert\">inverted（反转）</a> 以新建一个 step 来取消之前 step 所做的影响， 而且可以在一个叫做 <a href=\"#transform.Transform\"><code>Transform</code></a> 的对象上方便的链式调用。",
    "_note": ""
  },
  "A step object represents an atomic change. It generally applies only to the document it was created for, since the positions stored in it will only make sense for that document.": {
    "_translate": "一个 step 对象表示对文档的一个原子修改。大体上讲，它只会应用到创建它的那个文档上去，因为其内的位置信息只有对那个文档来说才有意义。",
    "_note": ""
  },
  "Applies this step to the given document, returning a result object that either indicates failure, if the step can not be applied to this document, or indicates success by containing a transformed document.": {
    "_translate": "将当前 step 应用到给定的文档，返回一个结果对象，对象可能表示失败，如果 step 不能被应用到文档中； 也可能表示成功，此时它会包含一个转换后的文档。",
    "_note": ""
  },
  "New steps are defined by creating classes that extend Step, overriding the apply, invert, map, getMap and fromJSON methods, and registering your class with a unique JSON-serialization identifier using Step.jsonID.": {
    "_translate": "新的 steps 通过创建扩展自 <code>Step</code> 的类来定义，其覆盖了 <code>apply</code>、<code>invert</code>、<code>map</code>、<code>getMap</code> 和 <code>fromJSON</code> 方法， 此外注册类的时候还需要使用 <a href=\"#transform.Step%5EjsonID\"><code>Step.jsonID</code></a> 来生成一个唯一的 JSON 序列化过的标识符。",
    "_note": ""
  },
  "Get the step map that represents the changes made by this step, and which can be used to transform between positions in the old and the new document.": {
    "_translate": "获取由当前 step 产生的表示文档变化的 step map，可以用来在新旧两个文档之间转换位置。",
    "_note": ""
  },
  "Create an inverted version of this step. Needs the document as it was before the step as argument.": {
    "_translate": "新建一个当前 step 相反的 step 版本，需要 step 之前的文档作为参数。",
    "_note": ""
  },
  "Map this step through a mappable thing, returning either a version of that step with its positions adjusted, or null if the step was entirely deleted by the mapping.": {
    "_translate": "通过一个可 mappable 的东西来 map 当前 step，返回值可能是一个调整过位置的 step 版本， 或者 <code>null</code>，如果 step 完全被这个 mapping 删除的话。",
    "_note": ""
  },
  "Try to merge this step with another one, to be applied directly after it. Returns the merged step when possible, null if the steps can't be merged.": {
    "_translate": "试着合并当前 step 与给定的 step，会被直接应用到当前 step 之后。如果可能的话，会返回合并之后的 step， 如果 step 不能被合并，则返回 null。",
    "_note": ""
  },
  "Create a JSON-serializeable representation of this step. When defining this for a custom subclass, make sure the result object includes the step type's JSON id under the stepType property.": {
    "_translate": "新建一个当前 step JSON 序列化后的版本。如果为一个自定义的子类定义了该方法，则需要确保返回的结果对象的 <code>stepType</code> 属性值是 step 类型的 <a href=\"#transform.Step%5EjsonID\">JSON id</a>。",
    "_note": ""
  },
  "To be able to serialize steps to JSON, each step needs a string ID to attach to its JSON representation. Use this method to register an ID for your step classes. Try to pick something that's unlikely to clash with steps from other modules.": {
    "_translate": "为了能够将 steps 序列化为 JSON 形式，每个 step 都需要一个字符串 ID 附加到它自己的 JSON 形式上去。 使用这个方法为你的 step 类注册一个 ID。需要避免与其他模块的 step 的命名冲突。",
    "_note": ""
  },
  "The result of applying a step. Contains either a new document or a failure value.": {
    "_translate": "<a href=\"#transform.Step.apply\">applying（应用）</a> 一个 step 的结果。可能包含一个新的文档或者是一个失败的值。",
    "_note": ""
  },
  "Deserialize a step from its JSON representation. Will call through to the step class' own implementation of this method.": {
    "_translate": "从一个 step 的 JSON 形式反序列化为一个 step。将会调用 step 类自己实现的此方法。",
    "_note": ""
  },
  "The transformed document, if successful.": {
    "_translate": "如果成功，转换后的文档。",
    "_note": ""
  },
  "The failure message, if unsuccessful.": {
    "_translate": "失败消息，如果不成功。",
    "_note": ""
  },
  "Create a successful step result.": {
    "_translate": "创建一个成功的 step 结果。",
    "_note": ""
  },
  "Call Node.replace with the given arguments. Create a successful result if it succeeds, and a failed one if it throws a ReplaceError.": {
    "_translate": "用给定的参数调用 <a href=\"#model.Node.replace\"><code>Node.replace</code></a>。如果成功就返回一个成功值， 如果它抛出一个 <code>ReplaceError</code> 则返回一个失败值。",
    "_note": ""
  },
  "Create a failed step result.": {
    "_translate": "创建一个失败的 step 结果。",
    "_note": ""
  },
  "Replace a part of the document with a slice of new content.": {
    "_translate": "用含有新内容的 slice 来替换文档的一部分。",
    "_note": ""
  },
  "The given slice should fit the 'gap' between from and to—the depths must line up, and the surrounding nodes must be able to be joined with the open sides of the slice. When structure is true, the step will fail if the content between from and to is not just a sequence of closing and then opening tokens (this is to guard against rebased replace steps overwriting something they weren't supposed to).": {
    "_translate": "给定的 slice 应该适应这个介于 <code>from</code> 和 <code>to</code> 之间的 「gap」，即 slice 两侧的深度和各自所接起来的位置深度必须是相同的，且 slice 周围 的节点必须能够接起来。当 <code>structure</code> 为 true 的时候，如果介意 from 和 to 之间的内容不是连续的先闭合后开放的标签，则 step 将会失败（这是为了 保证避免 rebased 的 replace step 意外覆盖了一些东西）。",
    "_note": ""
  },
  "The start position of the replaced range.": {
    "_translate": "替换范围的起始位置。",
    "_note": ""
  },
  "The end position of the replaced range.": {
    "_translate": "替换范围的结束位置。",
    "_note": ""
  },
  "The slice to insert.": {
    "_translate": "要插入的切片。",
    "_note": ""
  },
  "Replace a part of the document with a slice of content, but preserve a range of the replaced content by moving it into the slice.": {
    "_translate": "用一个 slice 的内容替换文档的一部分，不过会通过将被替换内容移动到 slice 中的方式来保留它的一个 range。",
    "_note": ""
  },
  "Create a replace-around step with the given range and gap. insert should be the point in the slice into which the content of the gap should be moved. structure has the same meaning as it has in the ReplaceStep class.": {
    "_translate": "用给定的 range 和 gap 来新建一个 replace-around step。 <code>insert</code> 应该指向的是在 slice 中 gap 的内容应该被放置的位置。 <code>structure</code> 有与它在 <a href=\"#transform.ReplaceStep\"><code>ReplaceStep</code></a> 类中相同的含义。",
    "_note": ""
  },
  "The start of preserved range.": {
    "_translate": "保存范围的开始。",
    "_note": ""
  },
  "The end of preserved range.": {
    "_translate": "保存范围的结束。",
    "_note": ""
  },
  "Add a mark to all inline content between two positions.": {
    "_translate": "在给定的两个位置中的所有内联元素上添加一个 mark。",
    "_note": ""
  },
  "The position in the slice where the preserved range should be inserted.": {
    "_translate": "在切片中应插入保留范围的位置。",
    "_note": ""
  },
  "Create a mark step.": {
    "_translate": "创建标记步骤。",
    "_note": ""
  },
  "The start of the marked range.": {
    "_translate": "标记范围的开始。",
    "_note": ""
  },
  "The end of the marked range.": {
    "_translate": "标记范围的结束。",
    "_note": ""
  },
  "The mark to add.": {
    "_translate": "添加标记。",
    "_note": ""
  },
  "Remove a mark from all inline content between two positions.": {
    "_translate": "在给定的两个位置中的所有内联元素上移除一个 mark。",
    "_note": ""
  },
  "Create a mark-removing step.": {
    "_translate": "创建一个去除标记的步骤。",
    "_note": ""
  },
  "The start of the unmarked range.": {
    "_translate": "未标记范围的开始。",
    "_note": ""
  },
  "The end of the unmarked range.": {
    "_translate": "未标记范围的结束。",
    "_note": ""
  },
  "The mark to remove.": {
    "_translate": "要删除的标记。",
    "_note": ""
  },
  "Add a mark to a specific node.": {
    "_translate": "在特定节点添加标记。",
    "_note": ""
  },
  "Create a node mark step.": {
    "_translate": "创建一个节点标记步骤。",
    "_note": ""
  },
  "The position of the target node.": {
    "_translate": "目标节点的位置。",
    "_note": ""
  },
  "Remove a mark from a specific node.": {
    "_translate": "从特定节点移除标记。",
    "_note": ""
  },
  "Update an attribute in a specific node.": {
    "_translate": "更新特定节点中的属性。",
    "_note": ""
  },
  "Construct an attribute step.": {
    "_translate": "构建属性步骤。",
    "_note": ""
  },
  "The attribute to set.": {
    "_translate": "要设置的属性。",
    "_note": ""
  },
  "Update an attribute in the doc node.": {
    "_translate": "更新文档节点中的属性。",
    "_note": ""
  },
  "Mapping positions from one document to another by running through the step maps produced by steps is an important operation in ProseMirror. It is used, for example, for updating the selection when the document changes.": {
    "_translate": "通过调用由 step 产生的 <a href=\"#transform.StepMap\">step maps</a> 来从一个文档中映射位置到另一个文档中在 ProseMirror 中是一个非常重要的操作。 例如，它被用来当文档改变的时候更新选区。",
    "_note": ""
  },
  "There are several things that positions can be mapped through. Such objects conform to this interface.": {
    "_translate": "位置可以被好几个对象 map，这类对象都符合该接口。",
    "_note": ""
  },
  "Map a position through this object. When given, assoc (should be -1 or 1, defaults to 1) determines with which side the position is associated, which determines in which direction to move when a chunk of content is inserted at the mapped position.": {
    "_translate": "通过该对象 map 一个位置。如果给定该方法，则 <code>assoc</code>（应该是 -1 或者 1，默认是 1） 决定位置与哪一侧有关，这决定了当一块内容被插入到被 map 的位置的时候，该位置应该往哪个方向移动。",
    "_note": ""
  },
  "Map a position, and return an object containing additional information about the mapping. The result's deleted field tells you whether the position was deleted (completely enclosed in a replaced range) during the mapping. When content on only one side is deleted, the position itself is only considered deleted when assoc points in the direction of the deleted content.": {
    "_translate": "map 一个位置，然后返回一个包含关于这个 mapping 附加信息的对象。结果的 <code>deleted</code> 字段会告诉你该位置在 map 期间是否被删除（在一个 replace 的 range 中完全闭合的位置，即两侧都删除），如果只有一侧被删除，则只有当 <code>assoc</code> 指向删除一侧的时候，这个位置才会被认为是删除了。",
    "_note": ""
  },
  "An object representing a mapped position with extra information.": {
    "_translate": "一个带有额外信息的表示一个 map 过的位置的对象。",
    "_note": ""
  },
  "The mapped version of the position.": {
    "_translate": "该位置 map 过的版本。",
    "_note": ""
  },
  "Tells you whether the position was deleted, that is, whether the step removed the token on the side queried (via the assoc) argument from the document.": {
    "_translate": "告诉您该位置是否已删除，即该 step 是否从文档中删除了通过<code>assoc</code>参数查询的一侧的标记。",
    "_note": ""
  },
  "Tells you whether the token before the mapped position was deleted.": {
    "_translate": "告诉您映射位置之前的标记是否被删除。",
    "_note": ""
  },
  "True when the token after the mapped position was deleted.": {
    "_translate": "当映射位置后的标记被删除时为真。",
    "_note": ""
  },
  "Tells whether any of the steps mapped through deletes across the position (including both the token before and after the position).": {
    "_translate": "告知是否有任何步骤通过删除跨越位置（包括位置前后的标记）。",
    "_note": ""
  },
  "A map describing the deletions and insertions made by a step, which can be used to find the correspondence between positions in the pre-step version of a document and the same position in the post-step version.": {
    "_translate": "一个 map 描述了由 step 产生的删除和插入操作，这可以用来找到应用 step 之前文档的位置和应用 step 之后文档的相同位置之间的对应关系。",
    "_note": ""
  },
  "Calls the given function on each of the changed ranges included in this map.": {
    "_translate": "对该 map 中的每一个修改的 range 调用给定的函数。",
    "_note": ""
  },
  "Create a position map. The modifications to the document are represented as an array of numbers, in which each group of three represents a modified chunk as [start, oldSize, newSize].": {
    "_translate": "新建一个位置 map。对文档的修改被表示为一个数字数组，在数组中每三个值表示一个修改区域，即 <code>[开始，旧大小，新大小]</code>。",
    "_note": ""
  },
  "Create an inverted version of this map. The result can be used to map positions in the post-step document to the pre-step document.": {
    "_translate": "新建一个该 map 的反转版本。函数返回的结果可以被用来将 step 修改后的文档位置 map 回 step 修改前的文档位置。",
    "_note": ""
  },
  "Create a map that moves all positions by offset n (which may be negative). This can be useful when applying steps meant for a sub-document to a larger document, or vice-versa.": {
    "_translate": "新建一个将所有位置偏移 <code>n</code> （n 可能为负数）的一个 map。当将一个子文档的 step 应用于一个较大文档的时候，这可能会很有用，反之亦然。",
    "_note": ""
  },
  "A StepMap that contains no changed ranges.": {
    "_translate": "一个不包含更改范围的StepMap。",
    "_note": ""
  },
  "A mapping represents a pipeline of zero or more step maps. It has special provisions for losslessly handling mapping positions through a series of steps in which some steps are inverted versions of earlier steps. (This comes up when ‘rebasing’ steps for collaboration or history management.)": {
    "_translate": "一个 mapping 表示 0 个或者更多个 <a href=\"#transform.StepMap\">step maps</a> 的管道。为了能够无损的处理通过一系列 step 而产生的位置 mapping， 其中一些 steps 很有可能是之前 step 的反转版本（这可能出现在为了协同编辑或者历史管理而 ‘<a href=\"/docs/guide/#transform.rebasing\">rebasing</a>’ step 的时候）因此有一些特殊的规定需要遵守。",
    "_note": ""
  },
  "Create a new mapping with the given position maps.": {
    "_translate": "用给定的位置 maps 新建一个 mapping。",
    "_note": ""
  },
  "The step maps in this mapping.": {
    "_translate": "在当前 mapping 中的 step maps。",
    "_note": ""
  },
  "The starting position in the maps array, used when map or mapResult is called.": {
    "_translate": "在 <code>maps</code> 数组中的起始位置，当 <code>map</code> 或者 <code>mapResult</code> 调用的时候会被使用。",
    "_note": ""
  },
  "The end position in the maps array.": {
    "_translate": "<code>maps</code> 位置的结束位置。",
    "_note": ""
  },
  "Create a mapping that maps only through a part of this one.": {
    "_translate": "新建一个 mapping，其只 map 当前 mapping 的一部分。",
    "_note": ""
  },
  "Add a step map to the end of this mapping. If mirrors is given, it should be the index of the step map that is the mirror image of this one.": {
    "_translate": "添加一个 step map 到当前 mapping 的末尾。如果设置了 <code>mirrors</code> 参数，则它应该是 step map 的索引，即第一个参数 step map 的镜像。",
    "_note": ""
  },
  "Add all the step maps in a given mapping to this one (preserving mirroring information).": {
    "_translate": "将给定 mapping 的所有 maps 添加到当前 mapping（保留镜像信息）。",
    "_note": ""
  },
  "Finds the offset of the step map that mirrors the map at the given offset, in this mapping (as per the second argument to appendMap).": {
    "_translate": "寻找给定偏移量位置的 map 的镜像 step map 的偏移量。",
    "_note": ""
  },
  "Append the inverse of the given mapping to this one.": {
    "_translate": "将给定 mapping 的相反顺序的 mapping 附加到当前 mapping 上。",
    "_note": ""
  },
  "Create an inverted version of this mapping.": {
    "_translate": "新建一个当前 mapping 包含相反 map 顺序的版本。",
    "_note": ""
  },
  "Map a position through this mapping.": {
    "_translate": "通过此映射映射一个位置。",
    "_note": ""
  },
  "Map a position through this mapping, returning a mapping result.": {
    "_translate": "通过此映射映射一个位置，返回一个映射结果。",
    "_note": ""
  },
  "Abstraction to build up and track an array of steps representing a document transformation.": {
    "_translate": "为了构建和跟踪文档 transformation 的一系列 steps 的抽象。",
    "_note": ""
  },
  "Because you often need to collect a number of steps together to effect a composite change, ProseMirror provides an abstraction to make this easy. State transactions are a subclass of transforms.": {
    "_translate": "由于你可能经常需要通过将一系列的 steps 合并到一起来修改文档，ProseMirror 提供了一个抽象来使这个过程简单化。 <a href=\"#state.Transaction\">State transactions</a> 就是这个抽象，它是 transforms 的子类。",
    "_note": "transaction 通常被简写为 tr。"
  },
  "Most transforming methods return the Transform object itself, so that they can be chained.": {
    "_translate": "大多数的 transforming 方法返回 <code>Transform</code> 对象本身，因此它们可以链式调用。",
    "_note": ""
  },
  "Create a transform that starts with the given document.": {
    "_translate": "新建一个起始于给定文档的 transform。",
    "_note": ""
  },
  "The steps in this transform.": {
    "_translate": "transform 中的 steps 们。",
    "_note": ""
  },
  "The documents before each of the steps.": {
    "_translate": "在每个 steps 开始之前的文档们。",
    "_note": ""
  },
  "A mapping with the maps for each of the steps in this transform.": {
    "_translate": "一个 maps 了 transform 中的每一个 steps 的 mapping。",
    "_note": ""
  },
  "The current document (the result of applying the steps in the transform).": {
    "_translate": "当前文档（即应用了 transform 中 steps 后的结果）。",
    "_note": ""
  },
  "The starting document.": {
    "_translate": "起始文档。",
    "_note": ""
  },
  "Apply a new step in this transform, saving the result. Throws an error when the step fails.": {
    "_translate": "对当前 transform 应用一个新的 step，然后保存结果。如果应用失败则抛出一个错误。",
    "_note": "错误的类叫做「TransformError」。"
  },
  "Try to apply a step in this transformation, ignoring it if it fails. Returns the step result.": {
    "_translate": "尝试在当前 transformation 中应用一个 step，如果失败则忽略，否则返回 step result。",
    "_note": ""
  },
  "True when the document has been changed (when there are any steps).": {
    "_translate": "如果文档被改变过（当有任何 step 的时候），则返回 true。",
    "_note": ""
  },
  "Replace the given range with the given content, which may be a fragment, node, or array of nodes.": {
    "_translate": "用给定的内容替换给定过的 range，该内容可能是一个 fragment、节点、或者节点数组。",
    "_note": ""
  },
  "Replace the part of the document between from and to with the given slice.": {
    "_translate": "用给定的 <code>slice</code> 替换在 <code>from</code> 和 <code>to</code> 之间的这部分文档。",
    "_note": ""
  },
  "Delete the content between the given positions.": {
    "_translate": "删除给定位置之间的内容。",
    "_note": ""
  },
  "Insert the given content at the given position.": {
    "_translate": "在给定的位置插入给定的内容。",
    "_note": ""
  },
  "Replace a range of the document with a given slice, using from, to, and the slice's openStart property as hints, rather than fixed start and end points. This method may grow the replaced area or close open nodes in the slice in order to get a fit that is more in line with WYSIWYG expectations, by dropping fully covered parent nodes of the replaced region when they are marked non-defining as context, or including an open parent node from the slice that is marked as defining its content.": {
    "_translate": "用<code>from</code>、<code>to</code>和 slice 的<a href=\"#model.Slice.openStart\"><code>openStart</code></a>属性作为提示来替换文档的一个 range，而不是固定的起点和终点。此方法可能会通过删除被标记为<a href=\"#model.NodeSpec.definingAsContext\">非定义上下文</a>的替换区域的完全覆盖的父节点，或包含切片中标记为<a href=\"#model.NodeSpec.definingForContent\">定义其内容</a>的开放父节点，以更符合所见即所得的期望，从而扩展替换区域或关闭切片中的开放节点。",
    "_note": ""
  },
  "This is the method, for example, to handle paste. The similar replace method is a more primitive tool which will not move the start and end of its given range, and is useful in situations where you need more precise control over what happens.": {
    "_translate": "这是处理粘贴的方法。例如，类似的<a href=\"#transform.Transform.replace\"><code>replace</code></a>方法是一个更原始的工具，它<em>不会</em>移动其给定范围的开始和结束，在需要更精确控制的情况下非常有用。",
    "_note": ""
  },
  "Replace the given range with a node, but use from and to as hints, rather than precise positions. When from and to are the same and are at the start or end of a parent node in which the given node doesn't fit, this method may move them out towards a parent that does allow the given node to be placed. When the given range completely covers a parent node, this method may completely replace that parent node.": {
    "_translate": "用给定的 node 替换一个由给定 <code>from</code> 和 <code>to</code> 模糊确定的 range，而不是一个精确的位置。 如果当 from 和 to 相同且都位于父级节点的起始或者结尾位置，而给定的 node 并不适合此位置的时候，该方法可能将 from 和 to 的范围 <em>扩大</em> 到 超出父级节点以允许给定的 node 被放置，如果给定的 range（from 和 to 形成的）完全覆盖了一个父级节点，则该方法可能完全替换掉这个父级节点。",
    "_note": ""
  },
  "Delete the given range, expanding it to cover fully covered parent nodes until a valid replace is found.": {
    "_translate": "删除给定的 range，会将该 range 扩大到完全覆盖父级节点，直到找到一个有效的替换为止。",
    "_note": "有些 range 两侧在不同深度的节点中，因此会先将二者的值扩展到与二者中深度与较小的那个保持一致以形成完全覆盖一个父级节点的 range。"
  },
  "Split the content in the given range off from its parent, if there is sibling content before or after it, and move it up the tree to the depth specified by target. You'll probably want to use liftTarget to compute target, to make sure the lift is valid.": {
    "_translate": "如果 range 内容前后有同级内容，则会将给定 range 从其父级节点中分割，然后将其沿树移动到由 <code>target</code> 指定的深度。你可能想要使用 <a href=\"#transform.liftTarget\"><code>liftTarget</code></a> 来计算 <code>target</code>，以保证这个沿着树的提升是有效的。",
    "_note": ""
  },
  "Join the blocks around the given position. If depth is 2, their last and first siblings are also joined, and so on.": {
    "_translate": "将给定位置周围的块级元素连接起来。如果深度是 2，它们最后和第一个同级节点也会被连接，以此类推。",
    "_note": ""
  },
  "Wrap the given range in the given set of wrappers. The wrappers are assumed to be valid in this position, and should probably be computed with findWrapping.": {
    "_translate": "用规定的包裹节点集合来包裹给定的 <a href=\"#model.NodeRange\">range</a>。包裹节点们会被假定是适合当前位置的，其应该被 <a href=\"#transform.findWrapping\"><code>findWrapping</code></a> 方法合适的计算出来。",
    "_note": ""
  },
  "Set the type of all textblocks (partly) between from and to to the given node type with the given attributes.": {
    "_translate": "将介于 <code>from</code> 和 <code>to</code> 之间的所有的文本块（部分地）设置成带有给定 attributes 的给定的节点类型。",
    "_note": "为什么是「部分的」是因为有些文本块或许不能被改变类型。"
  },
  "Change the type, attributes, and/or marks of the node at pos. When type isn't given, the existing node type is preserved,": {
    "_translate": "在给定的 <code>pos</code> 处改变节点的类型、attributes、或者/和 marks。如果 <code>type</code> 没有给，则保留当前节点的类型。",
    "_note": ""
  },
  "Set a single attribute on the document to a new value.": {
    "_translate": "将文档上的单个属性设置为新值。",
    "_note": ""
  },
  "Set a single attribute on a given node to a new value. The pos addresses the document content. Use setDocAttribute to set attributes on the document itself.": {
    "_translate": "将给定节点的单个属性设置为新值。 <code>pos</code> 地址文档内容。使用 <code>setDocAttribute</code> 设置文档本身的属性。",
    "_note": ""
  },
  "Add a mark to the node at position pos.": {
    "_translate": "在位置<code>pos</code>的节点添加一个标记。",
    "_note": ""
  },
  "Remove a mark (or a mark of the given type) from the node at position pos.": {
    "_translate": "从位置<code>pos</code>的节点中移除标记（或给定类型的标记）。",
    "_note": ""
  },
  "Split the node at the given position, and optionally, if depth is greater than one, any number of nodes above that. By default, the parts split off will inherit the node type of the original node. This can be changed by passing an array of types and attributes to use after the split.": {
    "_translate": "分割给定位置的节点，如果传入了 <code>depth</code> 参数，且其大于 1，则任何数量的节点在它之上（？？？）。 默认情况下，被分割部分的节点类型将会继承原始的节点类型，但是也可以通过传入一个类型数组和 attributes 来在分割后设置其上。",
    "_note": "这句英文原文也不通顺。"
  },
  "Add the given mark to the inline content between from and to.": {
    "_translate": "将给定的 mark 添加到 <code>from</code> 到 <code>to</code> 之间的内联节点中。",
    "_note": ""
  },
  "Remove marks from inline nodes between from and to. When mark is a single mark, remove precisely that mark. When it is a mark type, remove all marks of that type. When it is null, remove all marks of any type.": {
    "_translate": "将 <code>from</code> 到 <code>to</code> 之间的内联节点上给定的的 mark 移除。当 <code>mark</code> 是一个单独的 mark 时，则精确移除这个 mark。 如果是一个 mark 类型时，则移除所有的该类型的 mark。如果是 null，移除其内所有类型的 mark。",
    "_note": ""
  },
  "Removes all marks and nodes from the content of the node at pos that don't match the given new parent node type. Accepts an optional starting content match as third argument.": {
    "_translate": "从给定的 pos 移除与给定的新的父级节点类型不兼容的所有 marks 和节点们。 接受一个可选的起始 <a href=\"#model.ContentMatch\">content match</a> 作为第三个参数。",
    "_note": ""
  },
  "The following helper functions can be useful when creating transformations or determining whether they are even possible.": {
    "_translate": "当新建一个 transform 或者决定能否新建一个 transform 的时候，下面几个工具函数非常有用。",
    "_note": ""
  },
  "Try to find a target depth to which the content in the given range can be lifted. Will not go across isolating parent nodes.": {
    "_translate": "尝试寻找一个目标深度以让给定的 range 内的内容可以被提升（深度）。不会考虑有属性 <a href=\"#model.NodeSpec.isolating\">isolating</a> 存在的父级节点。",
    "_note": ""
  },
  "‘Fit’ a slice into a given position in the document, producing a step that inserts it. Will return null if there's no meaningful way to insert the slice here, or inserting it would be a no-op (an empty slice over an empty range).": {
    "_translate": "将一个 slice 「恰当的」放到文档中给定的位置，会生成一个进行插入操作的 step。如果没有一个有意义的途径来插入该 slice，或者插入的 slice 没有意义（比如一个空的 slice 带着空的 range）则返回 null。",
    "_note": ""
  },
  "Check whether splitting at the given position is allowed.": {
    "_translate": "检查给定的位置是否允许分割。",
    "_note": ""
  },
  "Try to find a valid way to wrap the content in the given range in a node of the given type. May introduce extra nodes around and inside the wrapper node, if necessary. Returns null if no valid wrapping could be found. When innerRange is given, that range's content is used as the content to fit into the wrapping, instead of the content of range.": {
    "_translate": "尝试找到一个有效的方式来用给定的节点类型包裹给定 range 的内容。如果必要的话，可能会在包裹节点的内部和周围生成额外的节点。 如果没有可用的包裹方式则返回 null。当 <code>innerRange</code> 给定的时候，该 range 的内容将会被作为被包裹的内容，而不是 <code>range</code> 的内容。",
    "_note": "需要研究一下 range 和 innerRange 的区别，若 range 包含多个同级节点和 range 只含有一个节点是否有区别？"
  },
  "Test whether the blocks before and after a given position can be joined.": {
    "_translate": "测试在给定位置之前或者之后的块级节点是否可以被连接起来。",
    "_note": ""
  },
  "Find an ancestor of the given position that can be joined to the block before (or after if dir is positive). Returns the joinable point, if any.": {
    "_translate": "寻找一个给定位置的祖先节点，该节点可以被连接到块级节点之前（或者之后，如果 <code>dir</code> 是正的话）。 如果找到，返回这个可加入的位置。",
    "_note": ""
  },
  "Try to find a point where a node of the given type can be inserted near pos, by searching up the node hierarchy when pos itself isn't a valid place but is at the start or end of a node. Return null if no position was found.": {
    "_translate": "当 <code>pos</code> 本身不是有效的位置但位于节点的起始或结尾处时，通过搜索节点的层级结构，尝试找到一个可以在给定位置的节点附近插入给定节点类型的点。 如果找不到位置，则返回 null。",
    "_note": ""
  },
  "Finds a position at or around the given position where the given slice can be inserted. Will look at parent nodes' nearest boundary and try there, even if the original position wasn't directly at the start or end of that node. Returns null when no position was found.": {
    "_translate": "寻找一个位置在给定的位置或者附近，以让给定的 slice能够插入。即使原始的位置并不直接在父级节点的起始或者结束位置， 也会尝试查看父级节点最近的边界然后尝试插入。如果找不到位置，则返回 null。",
    "_note": ""
  },
  "This module exports a number of commands, which are building block functions that encapsulate an editing action. A command function takes an editor state, optionally a dispatch function that it can use to dispatch a transaction and optionally an EditorView instance. It should return a boolean that indicates whether it could perform any action. When no dispatch callback is passed, the command should do a 'dry run', determining whether it is applicable, but not actually doing anything.": {
    "_translate": "本模块导出了一些 <em>命令</em>，它可以构建块级函数以封装一个编辑行为。一个命令函数接受一个编辑器的 state， 一个 <em>可选的</em> <code>dispatch</code> 函数，用来 dispatch 一个 transaction，及一个 <em>可选的</em> <code>EditorView</code> 实例作为参数。它应该返回一个布尔值以指示它是否可以执行任何行为。当没有 <code>dispatch</code> 回调被传入的时候， 该命令应该做一个 <code>空运行</code>，以决定它是否应该被运行，而不实际做任何事情。",
    "_note": ""
  },
  "These are mostly used to bind keys and define menu items.": {
    "_translate": "这些命令大多数用来绑定按键以及定义菜单项。",
    "_note": ""
  },
  "Combine a number of command functions into a single function (which calls them one by one until one returns true).": {
    "_translate": "组合多个命令函数到一个单独的函数（一个一个的调用这些命令，直到其中一个返回 true）。",
    "_note": ""
  },
  "Delete the selection, if there is one.": {
    "_translate": "删除选区，如果存在的话。",
    "_note": ""
  },
  "If the selection is empty and at the start of a textblock, try to reduce the distance between that block and the one before it—if there's a block directly before it that can be joined, join them. If not, try to move the selected block closer to the next one in the document structure by lifting it out of its parent or moving it into a parent of the previous block. Will use the view for accurate (bidi-aware) start-of-textblock detection if given.": {
    "_translate": "如果选区是空（光标）而且在一个文本块的起始位置，则试着减少光标所在的块级节点和该块级节点之前的节点之间的距离。如果存在一个块级节点直接位于 光标所在的块级节点之前而且能够被连接的话，则连接他们。如果不存在，则尝试通过将光标所在的块级节点从其父级节点中提升一级或者将其移动到父级节点之前的 块级节点中的方式来尝试将选择的块级节点（即光标所在的块级及诶单）移动的更接近文档中的下一个节点。如果给定 view 参数，则将会使用之以获取准确的（用来处理 bidi 的）文本块起始方向。",
    "_note": ""
  },
  "When the selection is empty and at the start of a textblock, select the node before that textblock, if possible. This is intended to be bound to keys like backspace, after joinBackward or other deleting commands, as a fall-back behavior when the schema doesn't allow deletion at the selected point.": {
    "_translate": "当选区是空且在一个文本块的起始位置的时候，如果可以的话，选中位于文本块之前的节点。这个行为通常倾向于在 <a href=\"#commands.joinBackward\"><code>joinBackward</code></a> 之后绑定向后删除键或者其他删除命令，以作为一个回退方案，如果 schema 不允许在选择的点进行删除操作的话。",
    "_note": "向后删除键在 Mac 上是 Ctrl + D，会删除光标右侧的内容。"
  },
  "A more limited form of joinBackward that only tries to join the current textblock to the one before it, if the cursor is at the start of a textblock.": {
    "_translate": "一种更有限的<a href=\"$commands.joinBackward\"><code>joinBackward</code></a>形式，仅在光标位于文本块开头时，尝试将当前文本块与之前的文本块连接起来。",
    "_note": ""
  },
  "If the selection is empty and the cursor is at the end of a textblock, try to reduce or remove the boundary between that block and the one after it, either by joining them or by moving the other block closer to this one in the tree structure. Will use the view for accurate start-of-textblock detection if given.": {
    "_translate": "如果选区是空而且光标在一个文本块的结尾处，则尝试减少或者移除当前块级元素和它之后的块级元素之间边界。可以通过连接他们或者在树中移动挨着当前块级元素的 其他块级元素。将会使用给定的 view（如果有）以获取准确的文本块起始方向。",
    "_note": ""
  },
  "A more limited form of joinForward that only tries to join the current textblock to the one after it, if the cursor is at the end of a textblock.": {
    "_translate": "一种更有限的<a href=\"$commands.joinForward\"><code>joinForward</code></a>形式，仅在光标位于文本块末尾时尝试将当前文本块与后面的文本块连接起来。",
    "_note": ""
  },
  "When the selection is empty and at the end of a textblock, select the node coming after that textblock, if possible. This is intended to be bound to keys like delete, after joinForward and similar deleting commands, to provide a fall-back behavior when the schema doesn't allow deletion at the selected point.": {
    "_translate": "当选区是空且在一个文本块的结尾位置的时候，如果可以的话，选中位于文本块之后的节点。这个行为通常倾向于在 <a href=\"#commands.joinForward\"><code>joinForward</code></a> 之后绑定删除键或者其他类似的删除命令，以作为一个回退方案，如果 schema 不允许在选择的点进行删除操作的话。",
    "_note": ""
  },
  "Join the selected block or, if there is a text selection, the closest ancestor block of the selection that can be joined, with the sibling above it.": {
    "_translate": "连接选择的块级节点，或者如果有文本选区，则连接与选区最接近的可连接的祖先节点和它之前的同级节点。",
    "_note": ""
  },
  "Join the selected block, or the closest ancestor of the selection that can be joined, with the sibling after it.": {
    "_translate": "连接选择的块级节点，或者连接与选区最接近的可连接的祖先节点和它之后的同级节点。",
    "_note": ""
  },
  "Lift the selected block, or the closest ancestor block of the selection that can be lifted, out of its parent node.": {
    "_translate": "从父级节点中提升选择的块级节点，或者提升与选区最接近的可提升的祖先节点。",
    "_note": ""
  },
  "If the selection is in a node whose type has a truthy code property in its spec, replace the selection with a newline character.": {
    "_translate": "如果选区在一个配置对象中 <a href=\"#model.NodeSpec.code\"><code>code</code></a> 属性为真值的节点类型中，则用一个换行符替换选区。",
    "_note": ""
  },
  "When the selection is in a node with a truthy code property in its spec, create a default block after the code block, and move the cursor there.": {
    "_translate": "如果选区在一个配置对象中 <a href=\"#model.NodeSpec.code\"><code>code</code></a> 属性为真值的节点类型中，则在当前代码块之后新建一个默认的块级节点， 然后将光标移动到其内。",
    "_note": ""
  },
  "If a block node is selected, create an empty paragraph before (if it is its parent's first child) or after it.": {
    "_translate": "如果一个块级节点被选中，则在其前面（如果它是其父级节点的第一个子元素）新建一个段落，或者其后面。",
    "_note": ""
  },
  "If the cursor is in an empty textblock that can be lifted, lift the block.": {
    "_translate": "如果光标在一个空的可以被提升的文本块中，那么提升这个文本块。",
    "_note": ""
  },
  "Split the parent block of the selection. If the selection is a text selection, also delete its content.": {
    "_translate": "分割选区的父级节点。如果选区是一个文本选区，还会同时删除选区内容。",
    "_note": ""
  },
  "Create a variant of splitBlock that uses a custom function to determine the type of the newly split off block.": {
    "_translate": "创建一个<a href=\"#commands.splitBlock\"><code>splitBlock</code></a>的变体，使用自定义函数来确定新分离块的类型。",
    "_note": ""
  },
  "Acts like splitBlock, but without resetting the set of active marks at the cursor.": {
    "_translate": "行为和 <a href=\"#commands.splitBlock\"><code>splitBlock</code></a> 类似，不过不会重置光标处已经激活的 marks 集合。",
    "_note": ""
  },
  "Move the selection to the node wrapping the current selection, if any. (Will not select the document node.)": {
    "_translate": "移动选区到包裹当前选区的节点中（如果有的话，不会选择文档根节点）。",
    "_note": ""
  },
  "Select the whole document.": {
    "_translate": "选择整个文档。",
    "_note": ""
  },
  "Moves the cursor to the start of current text block.": {
    "_translate": "将光标移动到当前文本块的开头。",
    "_note": ""
  },
  "Moves the cursor to the end of current text block.": {
    "_translate": "将光标移动到当前文本块的末尾。",
    "_note": ""
  },
  "Wrap the selection in a node of the given type with the given attributes.": {
    "_translate": "用带有给定 attributes 的给定类型的节点来包裹选区。",
    "_note": ""
  },
  "Returns a command that tries to set the selected textblocks to the given node type with the given attributes.": {
    "_translate": "返回一个尝试将选中的文本块设置为带有给定 attributes 的给定节点类型的命令。",
    "_note": ""
  },
  "Create a command function that toggles the given mark with the given attributes. Will return false when the current selection doesn't support that mark. This will remove the mark if any marks of that type exist in the selection, or add it otherwise. If the selection is empty, this applies to the stored marks instead of a range of the document.": {
    "_translate": "新建一个命令函数，控制带有给定 attributes 的给定 mark 的开关。如果当前选区不支持这个的 mark 将会返回 <code>false</code>。 这个过程将会移除在选区中存在的任何该种类型的 mark，或者如果没有的话则添加之。如果选区是空，则这将会应用到 stored marks](#state.EditorState.storedMarks) 中，而不是文档的某个范围。",
    "_note": ""
  },
  "Controls whether, when part of the selected range has the mark already and part doesn't, the mark is removed (true, the default) or added (false).": {
    "_translate": "控制当所选范围的一部分已经有标记而另一部分没有时，标记是被移除（<code>true</code>，默认）还是被添加（<code>false</code>）。",
    "_note": ""
  },
  "When set to false, this will prevent the command from acting on the content of inline nodes marked as atoms that are completely covered by a selection range.": {
    "_translate": "当设置为 false 时，这将阻止命令对标记为<a href=\"#model.NodeSpec.atom\">原子</a>的内联节点的内容进行操作，这些节点完全被选区范围覆盖。",
    "_note": ""
  },
  "Wrap a command so that, when it produces a transform that causes two joinable nodes to end up next to each other, those are joined. Nodes are considered joinable when they are of the same type and when the isJoinable predicate returns true for them or, if an array of strings was passed, if their node type name is in that array.": {
    "_translate": "封装一个命令，以便当它产生一个 transform 以引起两个可连接的节点彼此相邻时能够被连接。 当节点具有相同类型并且当 <code>isJoinable</code> 参数是函数时返回 true 或者参数是一个字符串数组而这些节点名在这个数组中时，节点将会被认为是可连接的。",
    "_note": ""
  },
  "Depending on the detected platform, this will hold pcBasekeymap or macBaseKeymap.": {
    "_translate": "取决于删除操作的平台，该值将指向 <a href=\"#commands.pcBaseKeymap\"><code>pcBasekeymap</code></a> 或者 <a href=\"#commands.macBaseKeymap\"><code>macBaseKeymap</code></a>。",
    "_note": ""
  },
  "A basic keymap containing bindings not specific to any schema. Binds the following keys (when multiple commands are listed, they are chained with chainCommands):": {
    "_translate": "一个基本的按键映射，包含不特定于任何 schema 的按键绑定。绑定包含下列按键（当多个命令被列出来的时候，它们被 <a href=\"#commands.chainCommands\"><code>chainCommands</code></a> 所链接起来）。",
    "_note": ""
  },
  "A copy of pcBaseKeymap that also binds Ctrl-h like Backspace, Ctrl-d like Delete, Alt-Backspace like Ctrl-Backspace, and Ctrl-Alt-Backspace, Alt-Delete, and Alt-d like Ctrl-Delete.": {
    "_translate": "<code>pcBaseKeymap</code> 的复制版，和 Backspace 一样绑定了 <strong>Ctrl-h</strong>，和 Delete 一样绑定了 <strong>Ctrl-d</strong>， 和 Ctrl-Backspace 一样绑定了 <strong>Alt-Backspace</strong>，和 Ctrl-Delete 一样绑定了 <strong>Ctrl-Alt-Backspace</strong>, <strong>Alt-Delete</strong>, 和 <strong>Alt-d</strong>",
    "_note": ""
  },
  "An implementation of an undo/redo history for ProseMirror. This history is selective, meaning it does not just roll back to a previous state but can undo some changes while keeping other, later changes intact. (This is necessary for collaborative editing, and comes up in other situations as well.)": {
    "_translate": "一个 ProseMirror 的撤销/重做历史的实现。撤销/重做的历史是 <em>可选择的</em>，这意味着它不仅仅是回滚到 之前的 state，而是可以在撤销部分修改的同时保留其他的修改，或者原封不动的保留之后的修改（这对于协同编辑来说 是很有必要的，在其他一些情况下也可能会发生）。",
    "_note": ""
  },
  "Returns a plugin that enables the undo history for an editor. The plugin will track undo and redo stacks, which can be used with the undo and redo commands.": {
    "_translate": "返回一个插件以使编辑器撤销历史可用。该插件将会追踪撤销和重做的操作栈，这可以和 <a href=\"#history.undo\"><code>撤销</code></a> and <a href=\"#history.redo\"><code>重做</code></a> 命令一同使用。",
    "_note": ""
  },
  "You can set an \"addToHistory\" metadata property of false on a transaction to prevent it from being rolled back by undo.": {
    "_translate": "你可以在一个 transaction 上设置一个 <code>\"addToHistory\"</code> 的 <a href=\"#state.Transaction.setMeta\">metadata 属性</a> 为 <code>false</code>，来阻止该 tr 被撤销回滚。",
    "_note": "设置了这个之后，该 tr 就相当于不会被加入到历史栈中。"
  },
  "The amount of history events that are collected before the oldest events are discarded. Defaults to 100.": {
    "_translate": "在最早的操作历史被丢弃之前，历史栈的最大长度，默认是 100。",
    "_note": "超过了就先丢弃最早的操作记录。"
  },
  "The delay between changes after which a new group should be started. Defaults to 500 (milliseconds). Note that when changes aren't adjacent, a new group is always started.": {
    "_translate": "操作从开始算起应该持续多久才会被算作一个操作。默认是 500（毫秒）。记住，如果多个修改不相邻的话，总是会被算作是新的操作。",
    "_note": "如果该值被设置为 500，则在 500 毫秒内输入 10 个字，这样会触发 10 个 tr，但是会被归为一「组」，撤销的时候直接撤销这 10 个字的输入记录。 如果 500 毫秒内输入 20 个字同理撤销这 20 个字的记录。如果在 500 毫秒内输入了 10 个字，在 501 毫秒内输入了第 11 个字，则撤销的时候，那第 501 毫秒输入的第 11 个字被算做是一组，先撤销那 1 个字的输入，再撤销那 10 个字的输入。这个逻辑是为了和系统输入保持一致，各位可以试试在系统的某个界面如搜索框变换输入速度来输入内容后 撤销，看会发生什么。"
  },
  "A command function that undoes the last change, if any.": {
    "_translate": "一个可以撤销最后修改（如果有）的命令函数。",
    "_note": ""
  },
  "A command function that redoes the last undone change, if any.": {
    "_translate": "一个可以重做最后一次撤销修改（如果有）的命令函数。",
    "_note": ""
  },
  "A command function that undoes the last change. Don't scroll the selection into view.": {
    "_translate": "一个撤销上次更改的命令功能。不要滚动选择到视图中。",
    "_note": ""
  },
  "A command function that redoes the last undone change. Don't scroll the selection into view.": {
    "_translate": "一个重做上次撤销更改的命令功能。不要滚动选择到视图中。",
    "_note": ""
  },
  "The amount of undoable events available in a given state.": {
    "_translate": "在给定的 state 中可以被撤销的操作的数量。",
    "_note": ""
  },
  "The amount of redoable events available in a given editor state.": {
    "_translate": "在给定的编辑器 state 中可以被重做的操作的数量。",
    "_note": ""
  },
  "Set a flag on the given transaction that will prevent further steps from being appended to an existing history event (so that they require a separate undo command to undo).": {
    "_translate": "在给定的 transaction 上设置一个标记，这将会阻止接下来的 steps 们被附加到一个已经存在的历史事件中（这样就需要一个单独的撤销命令来撤销了）。",
    "_note": "这个函数不能顾名思义的以为不会会将 tr 加入到历史栈中。正确理解应该是其会将本来能够一个 tr n 个 steps 完成的修改， 变成了 两个 tr，n/2 个 step。因此需要额外的撤销命令来撤销修改。「close」表示紧急中断该 tr，然后将剩余的 steps 放到一个新的 tr 中。"
  },
  "This module implements an API into which a communication channel for collaborative editing can be hooked. See the guide for more details and an example.": {
    "_translate": "这个模块实现了一个 API，该 API 可以供协同编辑使用。查看 <a href=\"/docs/guide/#collab\">指南</a> 以获取更多细节和示例。",
    "_note": ""
  },
  "Creates a plugin that enables the collaborative editing framework for the editor.": {
    "_translate": "创建一个能使编辑器支持协同编辑框架的插件。",
    "_note": ""
  },
  "The starting version number of the collaborative editing. Defaults to 0.": {
    "_translate": "协同编辑的起始版本号，默认是 0.",
    "_note": ""
  },
  "This client's ID, used to distinguish its changes from those of other clients. Defaults to a random 32-bit number.": {
    "_translate": "客户端 ID，用来分别哪些修改是自己做的哪些是其他客户端做的。默认是一个随机的 32 位数字。",
    "_note": ""
  },
  "Get the version up to which the collab plugin has synced with the central authority.": {
    "_translate": "获取 collab 插件与鉴权中心同步的版本。",
    "_note": ""
  },
  "Create a transaction that represents a set of new steps received from the authority. Applying this transaction moves the state forward to adjust to the authority's view of the document.": {
    "_translate": "创建一个接受自鉴权中心的表示新 steps 集合的 transaction。应用该 transaction 以将 state 向前移动来适应文档的鉴权中心的视图。",
    "_note": "「鉴权中心」指的就是协同处理的服务端，那里负责处理接受那些 tr，拒绝哪些 tr。"
  },
  "When enabled (the default is false), if the current selection is a text selection, its sides are mapped with a negative bias for this transaction, so that content inserted at the cursor ends up after the cursor. Users usually prefer this, but it isn't done by default for reasons of backwards compatibility.": {
    "_translate": "启用后（默认是 <code>false</code>），如果当前选区是一个 <a href=\"#state.TextSelection\">文本选区</a>，则它的两侧位置会被这个 transaction 通过一个负向偏移 mapped，以便使插入光标处的内容会以光标所在的位置结尾。用户通常倾向于这样做，不过因为向后兼容的 原因，默认情况下不会这么做。",
    "_note": ""
  },
  "Provides data describing the editor's unconfirmed steps, which need to be sent to the central authority. Returns null when there is nothing to send.": {
    "_translate": "提供编辑器未被确认的 steps 的数据描述，它会被发送给鉴权中心。如果没有需要发送的东西，返回 null。",
    "_note": ""
  },
  "origins holds the original transactions that produced each steps. This can be useful for looking up time stamps and other metadata for the steps, but note that the steps may have been rebased, whereas the origin transactions are still the old, unchanged objects.": {
    "_translate": "<code>origins</code> 值是产生每个 steps 的 <em>原始</em> transactions。对于寻找 steps 的时间戳和其他 metadata 信息很有用，不过记住，steps 可能会被 rebased， 因此原始的 transaction 仍然是旧的，未改变的对象。",
    "_note": ""
  },
  "A plugin for conveniently defining key bindings.": {
    "_translate": "一个为了方便的定义按键绑定的插件。",
    "_note": ""
  },
  "Create a keymap plugin for the given set of bindings.": {
    "_translate": "用给定的绑定集合来创建一个按键映射插件。",
    "_note": ""
  },
  "Bindings should map key names to command-style functions, which will be called with (EditorState, dispatch, EditorView) arguments, and should return true when they've handled the key. Note that the view argument isn't part of the command protocol, but can be used as an escape hatch if a binding needs to directly interact with the UI.": {
    "_translate": "绑定应该将按键名和 <a href=\"#commands\">命令</a> 格式的函数对应起来，该函数将会传入 <code>(EditorState, dispatch, EditorView)</code> 作为参数来调用，如果它响应了该按键按下，则应该返回 true。记住，view 参数并不是命令协议的一部分，但是如果按键绑定需要直接与 UI 交互，则可以将其用来作为应急出口使用。",
    "_note": ""
  },
  "Key names may be strings like \"Shift-Ctrl-Enter\"—a key identifier prefixed with zero or more modifiers. Key identifiers are based on the strings that can appear in KeyEvent.key. Use lowercase letters to refer to letter keys (or uppercase letters if you want shift to be held). You may use \"Space\" as an alias for the \" \" name.": {
    "_translate": "按键的名字可以是形如 <code>\"Shift-Ctrl-Enter\"</code> 的字符串，它是一个按键标识符，可以有 0 个或者多个修饰符做前缀。按键标识符的基础字符串基于这个 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\"><code>KeyEvent.key</code></a> 中的按键而来。使用小写字母来表示字母键 （或者使用大写字母，如果你想要处理 shift 被同时按下的情况）。你也许会使用 <code>\"Space\"</code> 作为 <code>\" \"</code> 的别名。",
    "_note": ""
  },
  "Modifiers can be given in any order. Shift- (or s-), Alt- (or a-), Ctrl- (or c- or Control-) and Cmd- (or m- or Meta-) are recognized. For characters that are created by holding shift, the Shift- prefix is implied, and should not be added explicitly.": {
    "_translate": "修饰符可以以任何顺序给定。只允许 <code>Shift-</code>（或者 <code>s-</code>)，<code>Alt-</code>（或者 <code>a-</code>），<code>Ctrl-</code>（或 <code>c-</code> 或 <code>Control-</code>）及 <code>Cmd-</code>（或 <code>m-</code> 或 <code>Meta-</code>） 这些修饰符出现。对于通过按下 shift 创建的字符，则 <code>Shift-</code> 前缀就是隐式的，不应该再显式添加了。",
    "_note": ""
  },
  "You can use Mod- as a shorthand for Cmd- on Mac and Ctrl- on other platforms.": {
    "_translate": "在 Mac 上你可以使用 <code>Mod-</code> 作为 <code>Cmd-</code> 的简称，在其他平台可以使用 <code>Ctrl-</code>。",
    "_note": ""
  },
  "You can add multiple keymap plugins to an editor. The order in which they appear determines their precedence (the ones early in the array get to dispatch first).": {
    "_translate": "你可以在编辑器中添加多个按键映射插件。它们出现的顺序决定了它们的优先级（数组前面的优先被 dispatch）。",
    "_note": ""
  },
  "This module defines a plugin for attaching input rules to an editor, which can react to or transform text typed by the user. It also comes with a bunch of default rules that can be enabled in this plugin.": {
    "_translate": "本模块定义了一个编辑器插件用来附加 <em>input rules（输入规则）</em>，它可以响应或者转换用户输入的文字。 本模块还带有一些默认的规则，可以通过本插件启用。",
    "_note": ""
  },
  "Given a set of bindings (using the same format as keymap), return a keydown handler that handles them.": {
    "_translate": "给定一组绑定（使用与<a href=\"#keymap.keymap\"><code>keymap</code></a>相同的格式），返回一个处理它们的<a href=\"#view.EditorProps.handleKeyDown\">keydown处理程序</a>。",
    "_note": ""
  },
  "Input rules are regular expressions describing a piece of text that, when typed, causes something to happen. This might be changing two dashes into an emdash, wrapping a paragraph starting with \"> \" into a blockquote, or something entirely different.": {
    "_translate": "输入规则是一些正则表达式，描述了输入何种文本会引起一些额外的变化。这个变化可能是将两个短斜杠变成一个长破折号，或者将以 <code>\"&gt; \"</code> 开头的段落用 blockquote 包裹着， 亦或者其他完全不一样的事情。",
    "_note": ""
  },
  "Create an input rule. The rule applies when the user typed something and the text directly in front of the cursor matches match, which should end with $.": {
    "_translate": "创建一个输入规则。规则会应用到当用户输入一些内容的时候，且直接在光标之前的文本会匹配 <code>match</code> 参数，该参数应该合适的用 <code>$</code> 结尾。",
    "_note": ""
  },
  "The handler can be a string, in which case the matched text, or the first matched group in the regexp, is replaced by that string.": {
    "_translate": "<code>handler</code> 参数可以是一个字符串，这种情况下表示匹配的文本，或者在正则中匹配的第一个组，会被该字符串替换。",
    "_note": ""
  },
  "Or a it can be a function, which will be called with the match array produced by RegExp.exec, as well as the start and end of the matched range, and which can return a transaction that describes the rule's effect, or null to indicate the input was not handled.": {
    "_translate": "它也可以是一个函数，会将调用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec\"><code>RegExp.exec</code></a> 后产生的 结果匹配数组传入作为参数来调用，以及匹配的起始和结束的范围。函数返回一个描述了规则影响的 <a href=\"#state.Transaction\">transaction</a>，或者如果输入没有被处理则返回 null。",
    "_note": ""
  },
  "When set to false, undoInputRule doesn't work on this rule.": {
    "_translate": "当设置为 false 时，<a href=\"#inputrules.undoInputRule\"><code>undoInputRule</code></a> 不适用于此规则。",
    "_note": ""
  },
  "By default, input rules will not apply inside nodes marked as code. Set this to true to change that, or to \"only\" to only match in such nodes.": {
    "_translate": "默认情况下，输入规则不会应用于标记为<a href=\"#model.NodeSpec.code\">code</a>的节点。将其设置为true以更改此设置，或设置为<code>\"only\"</code>以<em>仅</em>在此类节点中匹配。",
    "_note": ""
  },
  "Create an input rules plugin. When enabled, it will cause text input that matches any of the given rules to trigger the rule's action.": {
    "_translate": "创建一个输入规则插件。启用的话，将会导致与任何给定规则匹配的文本输入都会触发该规则对应的行为。",
    "_note": ""
  },
  "This is a command that will undo an input rule, if applying such a rule was the last thing that the user did.": {
    "_translate": "如果应用这个规则是用户做的最后一件事情的话，这是一个可以撤销输入规则的命令。",
    "_note": ""
  },
  "The module comes with a number of predefined rules:": {
    "_translate": "本模块还带有一些预定义的规则：",
    "_note": ""
  },
  "Converts double dashes to an emdash.": {
    "_translate": "转换两个短斜杠为一个长破折号的输入规则。",
    "_note": ""
  },
  "Converts three dots to an ellipsis character.": {
    "_translate": "转换三个点为一个省略号的输入规则。",
    "_note": ""
  },
  "“Smart” opening double quotes.": {
    "_translate": "「智能」打开双引号的输入规则。",
    "_note": ""
  },
  "“Smart” closing double quotes.": {
    "_translate": "「智能」关闭双引号的输入规则。",
    "_note": ""
  },
  "“Smart” opening single quotes.": {
    "_translate": "「智能」打开单引号的输入规则。",
    "_note": ""
  },
  "“Smart” closing single quotes.": {
    "_translate": "「智能」关闭单引号的输入规则。",
    "_note": ""
  },
  "Smart-quote related input rules.": {
    "_translate": "自动打开/关闭 单/双 引号相关的输入规则。",
    "_note": ""
  },
  "These utility functions take schema-specific parameters and create input rules specific to that schema.": {
    "_translate": "下列这些工具函数接受一个特定于 schema 的参数，并创建一个特定于 schema 的输入规则。",
    "_note": ""
  },
  "Build an input rule for automatically wrapping a textblock when a given string is typed. The regexp argument is directly passed through to the InputRule constructor. You'll probably want the regexp to start with ^, so that the pattern can only occur at the start of a textblock.": {
    "_translate": "当给定字符串被输入的时候构建一个输入规则以自动包裹一个文本块。<code>regexp</code> 参数被直接传给 <code>InputRule</code> 构造函数。你也许想要正则表达式以 <code>^</code> 开头， 这样的话就只会从一个文本块起始位置开始匹配。",
    "_note": "^ 表示正则中的起始位置匹配，一般用来做类似于 markdown 的输入规则，例如在文本块开头输入 # + 空格后，生成一个 h 元素。"
  },
  "nodeType is the type of node to wrap in. If it needs attributes, you can either pass them directly, or pass a function that will compute them from the regular expression match.": {
    "_translate": "<code>nodeType</code> 是要被包裹进的节点类型。如果它需要 attributes，那么你既可以直接传入，也可以传入一个计算 attributes 的函数，该函数接受正则匹配的结果作为参数。",
    "_note": ""
  },
  "Build an input rule that changes the type of a textblock when the matched text is typed into it. You'll usually want to start your regexp with ^ to that it is only matched at the start of a textblock. The optional getAttrs parameter can be used to compute the new node's attributes, and works the same as in the wrappingInputRule function.": {
    "_translate": "构建一个输入规则，以当匹配的文本输入的时候能够改变文本块的类型。你的正则通常应该以 <code>^</code> 开头，这样它就会只匹配文本块的起始位置。 可选参数 <code>getAttrs</code> 可以被用来计算新节点的 attributes，功能和 <code>wrappingInputRule</code> 中的该函数一样。",
    "_note": ""
  },
  "By default, if there's a node with the same type above the newly wrapped node, the rule will try to join those two nodes. You can pass a join predicate, which takes a regular expression match and the node before the wrapped node, and can return a boolean to indicate whether a join should happen.": {
    "_translate": "默认情况下，如果有新的包裹节点之前有一个与之相同类型的节点，那么这个规则将会尝试 <a href=\"#transform.Transform.join\">join（连接）</a> 这两个节点。 你可以传递一个连接指示函数，它接受一个正则表达式的结果和在包裹节点之前的节点作为参数，返回一个指示连接是否应该进行的布尔值。",
    "_note": ""
  },
  "This is a plugin that adds a type of selection for focusing places that don't allow regular selection (such as positions that have a leaf block node, table, or the end of the document both before and after them).": {
    "_translate": "本插件为那些不允许正常选区的聚焦的位置（比如说该位置有叶子节点、表格、或者文档的起始和结尾处）添加一种选区的类型。",
    "_note": ""
  },
  "You'll probably want to load style/gapcursor.css, which contains basic styling for the simulated cursor (as a short, blinking horizontal stripe).": {
    "_translate": "你可能需要加载 <code>style/gapcursor.css</code> 这个文件，它包含了模拟光标的基本样式（即短的，闪烁的水平条纹）。",
    "_note": ""
  },
  "By default, gap cursor are only allowed in places where the default content node (in the schema content constraints) is a textblock node. You can customize this by adding an allowGapCursor property to your node specs—if it's true, gap cursor are allowed everywhere in that node, if it's false they are never allowed.": {
    "_translate": "默认情况下，gap 光标只允许放置于默认内容节点（通过 schema 的 content 限制）是文本节点的地方。你可以通过在节点配置对象中添加 <code>allowGapCursor</code> 属性来自定义这个行为，如果该值是 true，则 gap 光标被允许放置到该节点的任何位置，如果是 <code>false</code> 则表示永远不允许放置该种类型的光标。",
    "_note": ""
  },
  "Create a gap cursor plugin. When enabled, this will capture clicks near and arrow-key-motion past places that don't have a normally selectable position nearby, and create a gap cursor selection for them. The cursor is drawn as an element with class ProseMirror-gapcursor. You can either include style/gapcursor.css from the package's directory or add your own styles to make it visible.": {
    "_translate": "创建一个 gap 光标插件。如果启用的话，它将会捕获点击区域附近的和方向键经过的不允许有一个正常的可选择区域的地方，然后为它们创建一个 gap 光标选区。 光标元素的类名是 <code>ProseMirror-gapcursor</code>。你既可以从该包中直接引入 <code>style/gapcursor.css</code> 做样式文件，也可以添加你自己的样式以使它可见。",
    "_note": ""
  },
  "Gap cursor selections are represented using this class. Its $anchor and $head properties both point at the cursor position.": {
    "_translate": "这个类是 Gap 光标选区的表现形式。它的 <code>$anchor</code> 和 <code>$head</code> 属性都指向光标的位置。",
    "_note": ""
  },
  "Create a gap cursor.": {
    "_translate": "创建一个间隙光标。",
    "_note": ""
  },
  "This module defines a simple schema. You can use it directly, extend it, or just pick out a few node and mark specs to use in a new schema.": {
    "_translate": "本模块定义了一个简单的 schema。你可以直接拿来使用，或者扩展它，亦或者仅仅是抄其中的一些节点和 mark 的配置对象然后应用到新的 schema 中。",
    "_note": ""
  },
  "This schema roughly corresponds to the document schema used by CommonMark, minus the list elements, which are defined in the prosemirror-schema-list module.": {
    "_translate": "该 schema 大致对应于 <a href=\"http://commonmark.org/\">CommonMark</a> 使用的文档 schema，减去在 <a href=\"#schema-list\"><code>prosemirror-schema-list</code></a> 模块中定义的里列表元素。",
    "_note": ""
  },
  "To reuse elements from this schema, extend or read from its spec.nodes and spec.marks properties.": {
    "_translate": "为了能够从该 schema 中重用元素，可以扩展和读取 <code>spec.nodes</code> 和 <code>spec.marks</code> <a href=\"#model.Schema.spec\">属性</a>。",
    "_note": ""
  },
  "Specs for the nodes defined in this schema.": {
    "_translate": "定义在该 schema 中节点们的 <a href=\"#model.NodeSpec\">Specs（配置对象）</a>。",
    "_note": ""
  },
  "NodeSpec The top level document node.": {
    "_translate": "NodeSpec 顶级文档节点。",
    "_note": ""
  },
  "A plain paragraph textblock. Represented in the DOM as a <p> element.": {
    "_translate": "普通段落文本块。在 DOM 中表现为一个 <code>&lt;p&gt;</code> 元素。",
    "_note": ""
  },
  "A blockquote (<blockquote>) wrapping one or more blocks.": {
    "_translate": "一个引用块（<code>&lt;blockquote&gt;</code>）包裹一个或者多个块级节点。",
    "_note": ""
  },
  "A horizontal rule (<hr>).": {
    "_translate": "水平分隔线（<code>&lt;hr&gt;</code>）。",
    "_note": ""
  },
  "A heading textblock, with a level attribute that should hold the number 1 to 6. Parsed and serialized as <h1> to <h6> elements.": {
    "_translate": "标题文本块，带有一个 <code>level</code> 属性，该属性的值应该在 1 到 6 的范围。会被格式化和序列化为 <code>&lt;h1&gt;</code> 到 <code>&lt;h6&gt;</code> 元素。",
    "_note": ""
  },
  "A code listing. Disallows marks or non-text inline nodes by default. Represented as a <pre> element with a <code> element inside of it.": {
    "_translate": "代码块。默认情况下不允许 marks 和非文本行内节点。表现为一个包裹着 <code>&lt;code&gt;</code> 元素的 <code>&lt;pre&gt;</code> 元素。",
    "_note": ""
  },
  "The text node.": {
    "_translate": "文本节点。",
    "_note": ""
  },
  "An inline image (<img>) node. Supports src, alt, and href attributes. The latter two default to the empty string.": {
    "_translate": "行内图片节点。支持 <code>src</code>、<code>alt</code> 和 <code>href</code> 属性。后两者默认的值是空字符串。",
    "_note": ""
  },
  "A hard line break, represented in the DOM as <br>.": {
    "_translate": "强制换行符，在 DOM 中表示为 <code>&lt;br&gt;</code> 元素。",
    "_note": ""
  },
  "Specs for the marks in the schema.": {
    "_translate": "schema 中 marks 们的 <a href=\"#model.MarkSpec\">Specs（配置对象）</a>",
    "_note": ""
  },
  "A link. Has href and title attributes. title defaults to the empty string. Rendered and parsed as an <a> element.": {
    "_translate": "链接。有 <code>href</code> 和 <code>title</code> 属性。<code>title</code> 默认是空字符串。会被渲染和格式化为一个 <code>&lt;a&gt;</code> 元素。",
    "_note": ""
  },
  "An emphasis mark. Rendered as an <em> element. Has parse rules that also match <i> and font-style: italic.": {
    "_translate": "强调。渲染为一个 <code>&lt;em&gt;</code> 元素，格式化规则同样匹配 <code>&lt;i&gt;</code> 和 <code>font-style: italic</code>。",
    "_note": "这里可能是 em 加粗，或者 i/font-style: italic 斜体。"
  },
  "A strong mark. Rendered as <strong>, parse rules also match <b> and font-weight: bold.": {
    "_translate": "加粗。渲染为 <code>&lt;strong&gt;</code>，格式化规则同样匹配 <code>&lt;b&gt;</code> 和 <code>font-weight: bold</code>。",
    "_note": ""
  },
  "Code font mark. Represented as a <code> element.": {
    "_translate": "行内代码。表现为 <code>&lt;code&gt;</code> 元素。",
    "_note": ""
  },
  "This module exports list-related schema elements and commands. The commands assume lists to be nestable, with the restriction that the first child of a list item is a plain paragraph.": {
    "_translate": "本模块导出了列表相关的 schema 元素和命令。命令假设列表是可以被嵌套的，以及限制列表项的第一个元素必须为普通段落元素。",
    "_note": ""
  },
  "These are the node specs:": {
    "_translate": "下面这些是节点配置对象：",
    "_note": ""
  },
  "A bullet list node spec, represented in the DOM as <ul>.": {
    "_translate": "一个无序列表的节点配置对象，DOM 表示为 <code>&lt;ul&gt;</code>。",
    "_note": ""
  },
  "An ordered list node spec. Has a single attribute, order, which determines the number at which the list starts counting, and defaults to 1. Represented as an <ol> element.": {
    "_translate": "一个有序列表的 <a href=\"#model.NodeSpec\">节点配置对象</a>。有一个唯一的属性 <code>order</code>，它决定了列表从哪个数字开始计数，默认是 1。 表现形式是一个 <code>&lt;ol&gt;</code> 元素。",
    "_note": ""
  },
  "A list item (<li>) spec.": {
    "_translate": "列表项（<code>&lt;li&gt;</code>）的配置对象。",
    "_note": "li 父节点可以是 ol 也可以是 ul，高级用法还可以扩展为 todo。"
  },
  "Convenience function for adding list-related node types to a map specifying the nodes for a schema. Adds orderedList as \"ordered_list\", bulletList as \"bullet_list\", and listItem as \"list_item\".": {
    "_translate": "为 schema 方便的添加列表相关的节点类型到一个特定的节点类型的函数。<a href=\"#schema-list.orderedList\"><code>orderedList</code></a> 表示为 <code>\"ordered_list\"</code>， <a href=\"#schema-list.bulletList\"><code>bulletList</code></a> 表示为 <code>\"bullet_list\"</code>， 以及 <a href=\"#schema-list.listItem\"><code>listItem</code></a> 表示为 <code>\"list_item\"</code>。",
    "_note": ""
  },
  "itemContent determines the content expression for the list items. If you want the commands defined in this module to apply to your list structure, it should have a shape like \"paragraph block*\" or \"paragraph (ordered_list | bullet_list)*\". listGroup can be given to assign a group name to the list node types, for example \"block\".": {
    "_translate": "<code>itemContent</code> 决定了列表项的内容表达式。如果你想要在本模块中定义的命令应用于你自己的列表结构，则它的值应该是诸如 <code>\"paragraph block*\"</code> 或者 <code>\"paragraph (ordered_list | bullet_list)*\"</code> 之类的。<code>listGroup</code> 可以将列表节点类型分配到一个组名，比如 <code>\"block\"</code>。",
    "_note": ""
  },
  "Using this would look something like this:": {
    "_translate": "本模块使用方式应该像下面这样：",
    "_note": ""
  },
  "The following functions are commands:": {
    "_translate": "下列函数是 <a href=\"/docs/guide/#commands\">命令</a>：",
    "_note": ""
  },
  "Returns a command function that wraps the selection in a list with the given type an attributes. If dispatch is null, only return a value to indicate whether this is possible, but don't actually perform the change.": {
    "_translate": "返回一个命令函数，该函数用给定的类型和属性包裹位于 list 中的选区。如果 <code>dispatch</code> 参数是 null，则只返回一个指示该行为是否可能的值， 而不实际执行修改。",
    "_note": ""
  },
  "Build a command that splits a non-empty textblock at the top level of a list item by also splitting that list item.": {
    "_translate": "构建一个命令，它会通过分割列表项的直接子元素的非空文本节点的方式来分割一个列表项。",
    "_note": ""
  },
  "Acts like splitListItem, but without resetting the set of active marks at the cursor.": {
    "_translate": "像 <a href=\"#schema-list.splitListItem\"><code>splitListItem</code></a>，但不重置光标处的活动标记集。",
    "_note": ""
  },
  "Create a command to lift the list item around the selection up into a wrapping list.": {
    "_translate": "创建一个命令，该命令会提升选区所在的列表项到上一级列表中。",
    "_note": ""
  },
  "Create a command to sink the list item around the selection down into an inner list.": {
    "_translate": "创建一个命令，该命令会将选区所在的列表项缩进到一个内部列表中去。",
    "_note": ""
  },
  "Contents": {
    "_translate": "目录",
    "_note": ""
  },
  "Examples": {
    "_translate": "示例",
    "_note": ""
  },
  "Documentation": {
    "_translate": "文档",
    "_note": ""
  },
  "Discuss": {
    "_translate": "论坛",
    "_note": ""
  },
  "GitHub": {
    "_translate": "GitHub",
    "_note": ""
  },
  "Twitter": {
    "_translate": "Twitter",
    "_note": ""
  },
  "Reference manual": {
    "_translate": "参考手册",
    "_note": ""
  },
  "determine whether they apply to this state": {
    "_translate": "确定它们是否适用于该州",
    "_note": ""
  },
  "if dispatch was passed, perform their effect, possibly by passing a transaction to dispatch": {
    "_translate": "如果传递了<code>dispatch</code>，则执行其效果，可能通过将 transaction 传递给<code>dispatch</code>",
    "_note": ""
  },
  "if not, return false": {
    "_translate": "如果没有，则返回 false",
    "_note": ""
  },
  "return true": {
    "_translate": "返回真",
    "_note": ""
  },
  "Enter to newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock": {
    "_translate": "<strong>输入</strong>到<code>newlineInCode</code>，<code>createParagraphNear</code>，<code>liftEmptyBlock</code>，<code>splitBlock</code>",
    "_note": ""
  },
  "Mod-Enter to exitCode": {
    "_translate": "<strong>Mod-Enter</strong> 到 <code>exitCode</code>",
    "_note": ""
  },
  "Backspace and Mod-Backspace to deleteSelection, joinBackward, selectNodeBackward": {
    "_translate": "<strong>退格键</strong> 和 <strong>Mod-退格键</strong> 到 <code>deleteSelection</code>，<code>joinBackward</code>，<code>selectNodeBackward</code>",
    "_note": ""
  },
  "Delete and Mod-Delete to deleteSelection, joinForward, selectNodeForward": {
    "_translate": "<strong>删除</strong> 和 <strong>Mod-删除</strong> 到 <code>deleteSelection</code>，<code>joinForward</code>，<code>selectNodeForward</code>",
    "_note": ""
  },
  "Mod-Delete to deleteSelection, joinForward, selectNodeForward": {
    "_translate": "<strong>Mod-删除</strong> 到 <code>deleteSelection</code>，<code>joinForward</code>，<code>selectNodeForward</code>",
    "_note": ""
  },
  "Mod-a to selectAll": {
    "_translate": "<strong>Mod-a</strong> 到 <code>selectAll</code>",
    "_note": ""
  },
  "译者": {
    "_translate": "译者",
    "_note": ""
  }
}